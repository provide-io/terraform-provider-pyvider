terraform {
  required_providers {
    pyvider = {
      source  = "local/providers/pyvider"
      version = ">= 0.0.5"
    }
  }
}

provider "pyvider" {
  # Provider configuration
  # Add your configuration options here
}

# Generated by Plating - Executable Example
# === Resources ===

# local_directory
# Complete workspace setup for different development scenarios

variable "workspace_name" {
  description = "Name of the workspace to create"
  type        = string
  default     = "dev-workspace"
}

variable "workspace_type" {
  description = "Type of workspace: web, api, data, or fullstack"
  type        = string
  default     = "fullstack"
  validation {
    condition     = contains(["web", "api", "data", "fullstack"], var.workspace_type)
    error_message = "Workspace type must be one of: web, api, data, fullstack."
  }
}

data "pyvider_env_variables" "user_info" {
  keys = ["USER", "HOME"]
}

locals {
  workspace_root = "/tmp/workspaces/${var.workspace_name}"
  username = lookup(data.pyvider_env_variables.user_info.values, "USER", "developer")

  # Define workspace structures based on type
  workspace_configs = {
    web = {
      directories = ["src", "public", "assets", "styles", "scripts", "tests", "dist", "docs"]
      files = {
        "package.json" = {
          name         = var.workspace_name
          version      = "1.0.0"
          main         = "src/index.js"
          scripts = {
            start = "npm run dev"
            dev   = "webpack serve --mode development"
            build = "webpack --mode production"
            test  = "jest"
          }
        }
        "webpack.config.js" = "// Webpack configuration for ${var.workspace_name}"
        ".gitignore" = join("\n", [
          "node_modules/", "dist/", "*.log", ".env*", ".DS_Store"
        ])
      }
    }
    api = {
      directories = ["src", "controllers", "models", "routes", "middleware", "tests", "docs", "config", "logs"]
      files = {
        "package.json" = {
          name    = var.workspace_name
          version = "1.0.0"
          main    = "src/server.js"
          scripts = {
            start = "node src/server.js"
            dev   = "nodemon src/server.js"
            test  = "jest"
          }
        }
        "src/server.js" = "// Express server for ${var.workspace_name}"
        ".env.example" = join("\n", [
          "PORT=3000", "DATABASE_URL=postgresql://localhost:5432/${var.workspace_name}",
          "JWT_SECRET=your-secret-key", "NODE_ENV=development"
        ])
      }
    }
    data = {
      directories = ["notebooks", "data/raw", "data/processed", "data/external", "models", "reports", "scripts", "tests"]
      files = {
        "requirements.txt" = join("\n", [
          "pandas>=1.5.0", "numpy>=1.24.0", "matplotlib>=3.6.0",
          "seaborn>=0.12.0", "scikit-learn>=1.2.0", "jupyter>=1.0.0"
        ])
        "README.md" = "# ${var.workspace_name}\n\nData science workspace created with Terraform."
        ".gitignore" = join("\n", [
          "*.csv", "*.parquet", "__pycache__/", ".ipynb_checkpoints/",
          "data/raw/*", "!data/raw/.gitkeep", "models/*.pkl"
        ])
      }
    }
    fullstack = {
      directories = [
        "frontend/src", "frontend/public", "frontend/tests",
        "backend/src", "backend/tests", "backend/config",
        "database/migrations", "database/seeds",
        "docs", "scripts", "docker", "k8s"
      ]
      files = {
        "docker-compose.yml" = "# Docker Compose for ${var.workspace_name}"
        "README.md" = "# ${var.workspace_name}\n\nFullstack application workspace."
        ".env.example" = join("\n", [
          "# Frontend", "REACT_APP_API_URL=http://localhost:3001",
          "# Backend", "PORT=3001", "DATABASE_URL=postgresql://localhost:5432/${var.workspace_name}",
          "# Docker", "POSTGRES_DB=${var.workspace_name}", "POSTGRES_USER=dev", "POSTGRES_PASSWORD=devpass"
        ])
      }
    }
  }

  config = local.workspace_configs[var.workspace_type]
}

# Create workspace root
resource "pyvider_local_directory" "workspace_root" {
  path        = local.workspace_root
  permissions = "0o755"
}

# Create all directories for the workspace type
resource "pyvider_local_directory" "workspace_dirs" {
  for_each = toset(local.config.directories)

  path = "${local.workspace_root}/${each.value}"
  depends_on = [pyvider_local_directory.workspace_root]
}

# Create workspace-specific configuration files
resource "pyvider_file_content" "workspace_files" {
  for_each = local.config.files

  filename = "${pyvider_local_directory.workspace_root.path}/${each.key}"
  content = can(jsondecode(jsonencode(each.value))) && length(regexall("\\{|\\[", jsonencode(each.value))) > 0 ?
    jsonencode(each.value) : each.value

  depends_on = [pyvider_local_directory.workspace_root]
}

# Create common development files
resource "pyvider_file_content" "workspace_readme" {
  filename = "${pyvider_local_directory.workspace_root.path}/WORKSPACE_INFO.md"
  content = <<-EOF
    # ${var.workspace_name}

    **Type:** ${var.workspace_type}
    **Created:** ${timestamp()}
    **Owner:** ${local.username}

    ## Workspace Structure

    This ${var.workspace_type} workspace includes the following directories:

    ${join("\n", [for dir in local.config.directories : "- `${dir}/`"])}

    ## Getting Started

    1. Navigate to the workspace:
       ```bash
       cd ${local.workspace_root}
       ```

    2. Follow the setup instructions for your workspace type.

    ## Workspace Type: ${upper(var.workspace_type)}

    ${var.workspace_type == "web" ? "This is a frontend web development workspace with webpack configuration." : ""}
    ${var.workspace_type == "api" ? "This is a backend API development workspace with Express.js setup." : ""}
    ${var.workspace_type == "data" ? "This is a data science workspace with Python and Jupyter setup." : ""}
    ${var.workspace_type == "fullstack" ? "This is a fullstack development workspace with frontend, backend, and database components." : ""}

    ## Directory Permissions

    ${join("\n", [for dir_name, dir_resource in pyvider_local_directory.workspace_dirs :
      "- `${dir_name}`: ${dir_resource.permissions != null ? dir_resource.permissions : "default (0o755)"}"
    ])}

    ## File Count Monitoring

    ${join("\n", [for dir_name, dir_resource in pyvider_local_directory.workspace_dirs :
      "- `${dir_name}`: ${dir_resource.file_count} items"
    ])}
  EOF

  depends_on = [pyvider_local_directory.workspace_dirs]
}

# Create development helper scripts
resource "pyvider_local_directory" "scripts_dir" {
  path = "${local.workspace_root}/scripts"
  depends_on = [pyvider_local_directory.workspace_root]
}

resource "pyvider_file_content" "setup_script" {
  filename = "${pyvider_local_directory.scripts_dir.path}/setup.sh"
  content = <<-EOF
    #!/bin/bash
    set -e

    echo "Setting up ${var.workspace_name} (${var.workspace_type}) workspace..."

    # Navigate to workspace root
    cd "${local.workspace_root}"

    ${var.workspace_type == "web" || var.workspace_type == "fullstack" ? "echo 'Installing Node.js dependencies...'\nif [ -f package.json ]; then\n    npm install\nfi" : ""}

    ${var.workspace_type == "data" ? "echo 'Setting up Python environment...'\nif [ -f requirements.txt ]; then\n    pip install -r requirements.txt\nfi" : ""}

    ${var.workspace_type == "api" || var.workspace_type == "fullstack" ? "echo 'Setting up API environment...'\nif [ -f .env.example ]; then\n    cp .env.example .env\n    echo 'Created .env file from example'\nfi" : ""}

    echo "Workspace setup complete!"
    echo "Workspace location: ${local.workspace_root}"
    echo "Type: ${var.workspace_type}"
    echo "Created by: ${local.username}"
  EOF

  depends_on = [pyvider_local_directory.scripts_dir]
}

resource "pyvider_file_content" "cleanup_script" {
  filename = "${pyvider_local_directory.scripts_dir.path}/cleanup.sh"
  content = <<-EOF
    #!/bin/bash

    echo "Cleaning up ${var.workspace_name} workspace..."

    # Navigate to workspace root
    cd "${local.workspace_root}"

    # Clean common temporary files
    find . -name "*.log" -delete
    find . -name "*.tmp" -delete
    find . -name ".DS_Store" -delete

    ${var.workspace_type == "web" || var.workspace_type == "fullstack" ? "# Clean Node.js artifacts\nrm -rf node_modules/\nrm -rf dist/\nrm -rf build/" : ""}

    ${var.workspace_type == "data" ? "# Clean Python artifacts\nfind . -name '__pycache__' -type d -exec rm -rf {} +\nfind . -name '*.pyc' -delete\nrm -rf .ipynb_checkpoints/" : ""}

    ${var.workspace_type == "api" || var.workspace_type == "fullstack" ? "# Clean API artifacts\nrm -rf logs/*.log\nrm -f .env" : ""}

    echo "Cleanup complete!"
  EOF

  depends_on = [pyvider_local_directory.scripts_dir]
}

output "workspace_setup" {
  description = "Complete workspace setup information"
  value = {
    workspace_name = var.workspace_name
    workspace_type = var.workspace_type
    workspace_root = pyvider_local_directory.workspace_root.path
    created_by     = local.username

    structure = {
      directories = {
        for dir_name, dir_resource in pyvider_local_directory.workspace_dirs :
        dir_name => {
          path        = dir_resource.path
          file_count  = dir_resource.file_count
          permissions = dir_resource.permissions
        }
      }
      root_file_count = pyvider_local_directory.workspace_root.file_count
    }

    created_files = [for filename in keys(local.config.files) : filename]

    quick_start = {
      setup_command   = "cd ${local.workspace_root} && bash scripts/setup.sh"
      cleanup_command = "cd ${local.workspace_root} && bash scripts/cleanup.sh"
      workspace_info  = "${local.workspace_root}/WORKSPACE_INFO.md"
    }

    type_specific_info = {
      web = var.workspace_type == "web" ? {
        main_directory = "${local.workspace_root}/src"
        public_assets  = "${local.workspace_root}/public"
        build_output   = "${local.workspace_root}/dist"
      } : null

      api = var.workspace_type == "api" ? {
        server_file    = "${local.workspace_root}/src/server.js"
        routes_dir     = "${local.workspace_root}/routes"
        config_dir     = "${local.workspace_root}/config"
      } : null

      data = var.workspace_type == "data" ? {
        notebooks_dir  = "${local.workspace_root}/notebooks"
        raw_data_dir   = "${local.workspace_root}/data/raw"
        processed_dir  = "${local.workspace_root}/data/processed"
      } : null

      fullstack = var.workspace_type == "fullstack" ? {
        frontend_dir = "${local.workspace_root}/frontend"
        backend_dir  = "${local.workspace_root}/backend"
        database_dir = "${local.workspace_root}/database"
      } : null
    }
  }
}

# file_content
# Template-based configuration with dynamic content

# Read environment variables for the template
data "pyvider_env_variables" "app_vars" {
  keys = ["USER", "HOME", "HOSTNAME"]
}

# Create a configuration file using template functions
resource "pyvider_file_content" "app_properties" {
  filename = "/tmp/application.properties"
  content = join("\n", [
    "# Application Configuration",
    "# Generated on ${timestamp()}",
    "",
    "app.user=${lookup(data.pyvider_env_variables.app_vars.values, "USER", "unknown")}",
    "app.home=${lookup(data.pyvider_env_variables.app_vars.values, "HOME", "/tmp")}",
    "app.hostname=${lookup(data.pyvider_env_variables.app_vars.values, "HOSTNAME", "localhost")}",
    "",
    "# Database Configuration",
    "database.url=jdbc:postgresql://localhost:5432/myapp",
    "database.username=app_user",
    "database.pool.size=10",
    "",
    "# Feature Flags",
    "features.new_ui=true",
    "features.analytics=false"
  ])
}

# Create a shell script with executable content
resource "pyvider_file_content" "deploy_script" {
  filename = "/tmp/deploy.sh"
  content = templatefile("${path.module}/deploy.sh.tpl", {
    app_name = "my-terraform-app"
    version  = "1.0.0"
    user     = lookup(data.pyvider_env_variables.app_vars.values, "USER", "deploy")
  })
}

# Example template file content (this would be a separate .tpl file)
# #!/bin/bash
# set -e
#
# APP_NAME="${app_name}"
# VERSION="${version}"
# USER="${user}"
#
# echo "Deploying $APP_NAME version $VERSION as user $USER"
# echo "Timestamp: $(date)"
#
# # Add your deployment logic here
# echo "Deployment complete!"

output "template_outputs" {
  description = "Information about template-generated files"
  value = {
    properties_file = {
      path = pyvider_file_content.app_properties.filename
      hash = pyvider_file_content.app_properties.content_hash
    }
    deploy_script = {
      path = pyvider_file_content.deploy_script.filename
      hash = pyvider_file_content.deploy_script.content_hash
    }
  }
}

# timed_token
# API integration token examples

# Example 1: External API authentication
resource "pyvider_timed_token" "external_api" {
  name = "external-service-integration"
}

# Use token for API authentication
data "pyvider_http_api" "authenticated_request" {
  url = "https://api.example.com/v1/data"
  headers = {
    "Authorization" = "Bearer ${pyvider_timed_token.external_api.token}"
    "Content-Type"  = "application/json"
    "X-API-Version" = "2024-01-01"
    "X-Token-ID"    = pyvider_timed_token.external_api.id
  }
}

# Example 2: Webhook authentication token
resource "pyvider_timed_token" "webhook_auth" {
  name = "webhook-callback-auth"
}

# Configure webhook with temporary authentication
data "pyvider_http_api" "register_webhook" {
  url    = "https://webhooks.example.com/register"
  method = "POST"
  headers = {
    "Authorization" = "Bearer ${pyvider_timed_token.webhook_auth.token}"
    "Content-Type"  = "application/json"
  }
}

# Create webhook configuration file
resource "pyvider_file_content" "webhook_config" {
  filename = "/tmp/webhook_config.json"
  content = jsonencode({
    webhook = {
      endpoint = "https://our-service.example.com/webhook"
      authentication = {
        type = "bearer_token"
        token_id = pyvider_timed_token.webhook_auth.id
        token_name = pyvider_timed_token.webhook_auth.name
        expires_at = pyvider_timed_token.webhook_auth.expires_at
      }
      events = ["user.created", "user.updated", "user.deleted"]
      retry_policy = {
        max_attempts = 3
        backoff_seconds = [1, 5, 15]
      }
    }
    security = {
      verify_signature = true
      allowed_ips = ["192.168.1.0/24", "10.0.0.0/8"]
      rate_limit = {
        requests_per_minute = 100
        burst_limit = 10
      }
    }
  })
}

# Example 3: Database API token
resource "pyvider_timed_token" "database_api" {
  name = "database-service-token"
}

# Create database connection configuration
resource "pyvider_file_content" "database_api_config" {
  filename = "/tmp/database_api_config.json"
  content = jsonencode({
    database_api = {
      connection = {
        base_url = "https://db-api.example.com/v2"
        authentication = {
          method = "api_token"
          token_id = pyvider_timed_token.database_api.id
          token_name = pyvider_timed_token.database_api.name
          expires_at = pyvider_timed_token.database_api.expires_at
        }
        timeout_seconds = 30
        retry_attempts = 3
      }
      endpoints = {
        query = "/query"
        batch = "/batch"
        schema = "/schema"
        health = "/health"
      }
      permissions = {
        read = true
        write = false
        admin = false
      }
    }
    connection_pool = {
      max_connections = 10
      idle_timeout_seconds = 300
      connection_lifetime_hours = 1
    }
  })
}

# Example 4: Multi-service API orchestration
resource "pyvider_timed_token" "service_orchestrator" {
  name = "service-orchestration-token"
}

resource "pyvider_timed_token" "payment_service" {
  name = "payment-service-token"
}

resource "pyvider_timed_token" "notification_service" {
  name = "notification-service-token"
}

# Create service orchestration configuration
resource "pyvider_file_content" "service_orchestration" {
  filename = "/tmp/service_orchestration.json"
  content = jsonencode({
    orchestration = {
      coordinator = {
        token_id = pyvider_timed_token.service_orchestrator.id
        token_name = pyvider_timed_token.service_orchestrator.name
        expires_at = pyvider_timed_token.service_orchestrator.expires_at
      }

      services = {
        payment = {
          base_url = "https://payments.example.com/api/v1"
          token_id = pyvider_timed_token.payment_service.id
          token_name = pyvider_timed_token.payment_service.name
          expires_at = pyvider_timed_token.payment_service.expires_at
          timeout_seconds = 15
          retry_policy = "exponential_backoff"
        }

        notifications = {
          base_url = "https://notify.example.com/api/v1"
          token_id = pyvider_timed_token.notification_service.id
          token_name = pyvider_timed_token.notification_service.name
          expires_at = pyvider_timed_token.notification_service.expires_at
          timeout_seconds = 10
          retry_policy = "immediate_retry"
        }
      }

      workflows = {
        user_registration = {
          steps = [
            {
              service = "payment"
              endpoint = "/customers"
              method = "POST"
              timeout = 15
            },
            {
              service = "notifications"
              endpoint = "/welcome"
              method = "POST"
              timeout = 5
            }
          ]
          rollback_enabled = true
          max_duration_seconds = 60
        }
      }
    }

    monitoring = {
      health_checks = {
        enabled = true
        interval_seconds = 30
        failure_threshold = 3
      }
      token_expiration = {
        warn_before_minutes = 10
        auto_refresh = false
      }
    }
  })
}

# Example 5: GraphQL API integration
resource "pyvider_timed_token" "graphql_api" {
  name = "graphql-service-token"
}

# Create GraphQL client configuration
resource "pyvider_file_content" "graphql_config" {
  filename = "/tmp/graphql_config.json"
  content = jsonencode({
    graphql_client = {
      endpoint = "https://graphql.example.com/api"
      authentication = {
        type = "bearer_token"
        token_id = pyvider_timed_token.graphql_api.id
        token_name = pyvider_timed_token.graphql_api.name
        expires_at = pyvider_timed_token.graphql_api.expires_at
        header_name = "Authorization"
        header_format = "Bearer {token}"
      }

      introspection = {
        enabled = true
        cache_schema = true
        schema_ttl_minutes = 30
      }

      queries = {
        user_profile = {
          query = "query GetUser($id: ID!) { user(id: $id) { id name email profile { avatar bio } } }"
          variables = {
            id = "$USER_ID"
          }
        }
        user_posts = {
          query = "query GetUserPosts($userId: ID!, $limit: Int) { posts(userId: $userId, limit: $limit) { id title content createdAt } }"
          variables = {
            userId = "$USER_ID"
            limit = 10
          }
        }
      }

      mutations = {
        create_post = {
          mutation = "mutation CreatePost($input: PostInput!) { createPost(input: $input) { id title content author { name } } }"
          variables = {
            input = "$POST_INPUT"
          }
        }
      }

      subscriptions = {
        post_updates = {
          subscription = "subscription PostUpdates($userId: ID!) { postUpdated(userId: $userId) { id title content updatedAt } }"
          variables = {
            userId = "$USER_ID"
          }
        }
      }
    }

    client_options = {
      timeout_seconds = 30
      retry_attempts = 3
      batch_requests = true
      persistent_queries = false
    }
  })
}

# Example 6: Token rotation strategy for long-running integrations
resource "pyvider_timed_token" "primary_integration" {
  name = "primary-api-integration"
}

resource "pyvider_timed_token" "backup_integration" {
  name = "backup-api-integration"
}

# Create token rotation configuration
resource "pyvider_file_content" "token_rotation_strategy" {
  filename = "/tmp/token_rotation_strategy.json"
  content = jsonencode({
    token_rotation = {
      strategy = "blue_green"

      primary_token = {
        token_id = pyvider_timed_token.primary_integration.id
        token_name = pyvider_timed_token.primary_integration.name
        expires_at = pyvider_timed_token.primary_integration.expires_at
        status = "active"
        priority = 1
      }

      backup_token = {
        token_id = pyvider_timed_token.backup_integration.id
        token_name = pyvider_timed_token.backup_integration.name
        expires_at = pyvider_timed_token.backup_integration.expires_at
        status = "standby"
        priority = 2
      }

      rotation_policy = {
        trigger_before_expiry_minutes = 15
        overlap_period_minutes = 5
        validation_checks = [
          "token_format",
          "api_connectivity",
          "permission_validation"
        ]
        fallback_enabled = true
        notification_channels = ["email", "slack", "webhook"]
      }

      monitoring = {
        health_endpoint = "/health/tokens"
        check_interval_seconds = 60
        alert_on_failure = true
        metrics = {
          token_usage_rate = true
          api_response_times = true
          error_rates = true
          expiration_warnings = true
        }
      }
    }

    failover = {
      automatic = true
      max_retry_attempts = 3
      circuit_breaker = {
        failure_threshold = 5
        reset_timeout_seconds = 300
      }
    }
  })
}

# Create comprehensive API integration summary
resource "pyvider_file_content" "api_integration_summary" {
  filename = "/tmp/api_integration_summary.txt"
  content = join("\n", [
    "=== API Integration Token Summary ===",
    "",
    "External API Integration:",
    "  Token: ${pyvider_timed_token.external_api.name}",
    "  ID: ${pyvider_timed_token.external_api.id}",
    "  Expires: ${pyvider_timed_token.external_api.expires_at}",
    "  API Status: ${data.pyvider_http_api.authenticated_request.status_code}",
    "",
    "Webhook Authentication:",
    "  Token: ${pyvider_timed_token.webhook_auth.name}",
    "  ID: ${pyvider_timed_token.webhook_auth.id}",
    "  Expires: ${pyvider_timed_token.webhook_auth.expires_at}",
    "  Registration Status: ${data.pyvider_http_api.register_webhook.status_code}",
    "",
    "Database API Integration:",
    "  Token: ${pyvider_timed_token.database_api.name}",
    "  ID: ${pyvider_timed_token.database_api.id}",
    "  Expires: ${pyvider_timed_token.database_api.expires_at}",
    "",
    "Service Orchestration:",
    "  Coordinator: ${pyvider_timed_token.service_orchestrator.name}",
    "  Payment Service: ${pyvider_timed_token.payment_service.name}",
    "  Notification Service: ${pyvider_timed_token.notification_service.name}",
    "",
    "GraphQL Integration:",
    "  Token: ${pyvider_timed_token.graphql_api.name}",
    "  ID: ${pyvider_timed_token.graphql_api.id}",
    "  Expires: ${pyvider_timed_token.graphql_api.expires_at}",
    "",
    "Token Rotation Strategy:",
    "  Primary: ${pyvider_timed_token.primary_integration.name}",
    "  Backup: ${pyvider_timed_token.backup_integration.name}",
    "",
    "Security Features:",
    "  ✅ Time-limited tokens (1 hour expiration)",
    "  ✅ Sensitive data protection",
    "  ✅ Automatic token rotation support",
    "  ✅ Multi-service orchestration",
    "  ✅ Fallback and redundancy",
    "",
    "Integration Patterns Demonstrated:",
    "  - REST API authentication",
    "  - Webhook registration and callbacks",
    "  - Database service integration",
    "  - Multi-service orchestration",
    "  - GraphQL API integration",
    "  - Token rotation strategies",
    "",
    "Generated at: ${timestamp()}"
  ])
}

output "api_integration_results" {
  description = "API integration token configurations and results"
  value = {
    integrations = {
      external_api = {
        token_name = pyvider_timed_token.external_api.name
        token_id = pyvider_timed_token.external_api.id
        expires_at = pyvider_timed_token.external_api.expires_at
        api_status = data.pyvider_http_api.authenticated_request.status_code
        api_success = data.pyvider_http_api.authenticated_request.status_code >= 200 && data.pyvider_http_api.authenticated_request.status_code < 300
      }

      webhook = {
        token_name = pyvider_timed_token.webhook_auth.name
        token_id = pyvider_timed_token.webhook_auth.id
        expires_at = pyvider_timed_token.webhook_auth.expires_at
        registration_status = data.pyvider_http_api.register_webhook.status_code
        registration_success = data.pyvider_http_api.register_webhook.status_code >= 200 && data.pyvider_http_api.register_webhook.status_code < 300
      }

      database_api = {
        token_name = pyvider_timed_token.database_api.name
        token_id = pyvider_timed_token.database_api.id
        expires_at = pyvider_timed_token.database_api.expires_at
      }

      graphql = {
        token_name = pyvider_timed_token.graphql_api.name
        token_id = pyvider_timed_token.graphql_api.id
        expires_at = pyvider_timed_token.graphql_api.expires_at
      }
    }

    service_orchestration = {
      coordinator = pyvider_timed_token.service_orchestrator.name
      payment_service = pyvider_timed_token.payment_service.name
      notification_service = pyvider_timed_token.notification_service.name
      all_services_configured = true
    }

    token_rotation = {
      primary_token = pyvider_timed_token.primary_integration.name
      backup_token = pyvider_timed_token.backup_integration.name
      strategy = "blue_green"
      redundancy_enabled = true
    }

    summary = {
      total_tokens = 8
      integration_types = ["REST API", "Webhook", "Database API", "GraphQL", "Service Orchestration"]
      security_features = ["Time-limited", "Sensitive data protection", "Token rotation", "Failover support"]
    }

    configuration_files = [
      pyvider_file_content.webhook_config.filename,
      pyvider_file_content.database_api_config.filename,
      pyvider_file_content.service_orchestration.filename,
      pyvider_file_content.graphql_config.filename,
      pyvider_file_content.token_rotation_strategy.filename,
      pyvider_file_content.api_integration_summary.filename
    ]
  }
}

# private_state_verifier
# CI/CD pipeline integration examples for private state verification

variable "ci_environment" {
  description = "CI/CD environment identifier"
  type        = string
  default     = "ci-test"
}

variable "build_number" {
  description = "Build number or identifier"
  type        = string
  default     = "local-build"
}

variable "test_suite" {
  description = "Test suite configuration"
  type = object({
    name = string
    parallel_tests = bool
    timeout_minutes = number
    failure_threshold = number
  })
  default = {
    name = "private-state-verification"
    parallel_tests = true
    timeout_minutes = 10
    failure_threshold = 0
  }
}

# CI/CD test matrix - multiple test scenarios
locals {
  ci_test_matrix = {
    smoke_test = {
      input = "ci-smoke-test-${var.build_number}"
      description = "Basic functionality verification"
      priority = "critical"
      timeout = 60
    }
    integration_test = {
      input = "ci-integration-${var.ci_environment}-${var.build_number}"
      description = "Integration testing with CI environment"
      priority = "high"
      timeout = 120
    }
    regression_test = {
      input = "ci-regression-validation-${var.build_number}"
      description = "Regression testing for known issues"
      priority = "high"
      timeout = 180
    }
    performance_test = {
      input = "ci-performance-benchmark-${var.build_number}"
      description = "Performance and scalability verification"
      priority = "medium"
      timeout = 300
    }
    security_test = {
      input = "ci-security-scan-${var.build_number}"
      description = "Security vulnerability assessment"
      priority = "critical"
      timeout = 240
    }
    compatibility_test = {
      input = "ci-compatibility-${var.ci_environment}"
      description = "Environment compatibility verification"
      priority = "medium"
      timeout = 150
    }
  }
}

# Create test instances for each test in the matrix
resource "pyvider_private_state_verifier" "ci_test_matrix" {
  for_each = local.ci_test_matrix

  input_value = each.value.input
}

# Example 1: GitHub Actions CI/CD integration
resource "pyvider_private_state_verifier" "github_actions_test" {
  input_value = "github-actions-${var.ci_environment}-${var.build_number}"
}

# Example 2: Jenkins pipeline integration
resource "pyvider_private_state_verifier" "jenkins_test" {
  input_value = "jenkins-pipeline-${var.ci_environment}-${var.build_number}"
}

# Example 3: GitLab CI integration
resource "pyvider_private_state_verifier" "gitlab_ci_test" {
  input_value = "gitlab-ci-${var.ci_environment}-${var.build_number}"
}

# Example 4: Azure DevOps integration
resource "pyvider_private_state_verifier" "azure_devops_test" {
  input_value = "azure-devops-${var.ci_environment}-${var.build_number}"
}

# Example 5: CircleCI integration
resource "pyvider_private_state_verifier" "circleci_test" {
  input_value = "circleci-${var.ci_environment}-${var.build_number}"
}

# Test results validation
locals {
  ci_test_results = {
    for test_name, test_config in local.ci_test_matrix :
    test_name => {
      input = pyvider_private_state_verifier.ci_test_matrix[test_name].input_value
      output = pyvider_private_state_verifier.ci_test_matrix[test_name].decrypted_token
      expected = "SECRET_FOR_${upper(test_config.input)}"
      passed = pyvider_private_state_verifier.ci_test_matrix[test_name].decrypted_token == "SECRET_FOR_${upper(test_config.input)}"
      description = test_config.description
      priority = test_config.priority
      timeout = test_config.timeout
      duration = 1 # Simulated test duration in seconds
    }
  }

  platform_test_results = {
    github_actions = {
      input = pyvider_private_state_verifier.github_actions_test.input_value
      output = pyvider_private_state_verifier.github_actions_test.decrypted_token
      expected = "SECRET_FOR_GITHUB-ACTIONS-${upper(var.ci_environment)}-${upper(var.build_number)}"
      passed = pyvider_private_state_verifier.github_actions_test.decrypted_token == "SECRET_FOR_GITHUB-ACTIONS-${upper(var.ci_environment)}-${upper(var.build_number)}"
      platform = "GitHub Actions"
    }
    jenkins = {
      input = pyvider_private_state_verifier.jenkins_test.input_value
      output = pyvider_private_state_verifier.jenkins_test.decrypted_token
      expected = "SECRET_FOR_JENKINS-PIPELINE-${upper(var.ci_environment)}-${upper(var.build_number)}"
      passed = pyvider_private_state_verifier.jenkins_test.decrypted_token == "SECRET_FOR_JENKINS-PIPELINE-${upper(var.ci_environment)}-${upper(var.build_number)}"
      platform = "Jenkins"
    }
    gitlab_ci = {
      input = pyvider_private_state_verifier.gitlab_ci_test.input_value
      output = pyvider_private_state_verifier.gitlab_ci_test.decrypted_token
      expected = "SECRET_FOR_GITLAB-CI-${upper(var.ci_environment)}-${upper(var.build_number)}"
      passed = pyvider_private_state_verifier.gitlab_ci_test.decrypted_token == "SECRET_FOR_GITLAB-CI-${upper(var.ci_environment)}-${upper(var.build_number)}"
      platform = "GitLab CI"
    }
    azure_devops = {
      input = pyvider_private_state_verifier.azure_devops_test.input_value
      output = pyvider_private_state_verifier.azure_devops_test.decrypted_token
      expected = "SECRET_FOR_AZURE-DEVOPS-${upper(var.ci_environment)}-${upper(var.build_number)}"
      passed = pyvider_private_state_verifier.azure_devops_test.decrypted_token == "SECRET_FOR_AZURE-DEVOPS-${upper(var.ci_environment)}-${upper(var.build_number)}"
      platform = "Azure DevOps"
    }
    circleci = {
      input = pyvider_private_state_verifier.circleci_test.input_value
      output = pyvider_private_state_verifier.circleci_test.decrypted_token
      expected = "SECRET_FOR_CIRCLECI-${upper(var.ci_environment)}-${upper(var.build_number)}"
      passed = pyvider_private_state_verifier.circleci_test.decrypted_token == "SECRET_FOR_CIRCLECI-${upper(var.ci_environment)}-${upper(var.build_number)}"
      platform = "CircleCI"
    }
  }

  # Overall CI/CD test summary
  ci_summary = {
    total_matrix_tests = length(local.ci_test_results)
    matrix_tests_passed = length([for test in local.ci_test_results : test if test.passed])
    matrix_tests_failed = length([for test in local.ci_test_results : test if !test.passed])

    total_platform_tests = length(local.platform_test_results)
    platform_tests_passed = length([for test in local.platform_test_results : test if test.passed])
    platform_tests_failed = length([for test in local.platform_test_results : test if !test.passed])

    overall_tests_passed = (
      length([for test in local.ci_test_results : test if test.passed]) +
      length([for test in local.platform_test_results : test if test.passed])
    )
    overall_tests_failed = (
      length([for test in local.ci_test_results : test if !test.passed]) +
      length([for test in local.platform_test_results : test if !test.passed])
    )

    critical_failures = length([
      for test in local.ci_test_results : test
      if !test.passed && test.priority == "critical"
    ])

    all_tests_passed = (
      alltrue([for test in local.ci_test_results : test.passed]) &&
      alltrue([for test in local.platform_test_results : test.passed])
    )

    ci_status = (
      alltrue([for test in local.ci_test_results : test.passed]) &&
      alltrue([for test in local.platform_test_results : test.passed])
    ) ? "success" : "failure"

    exit_code = (
      alltrue([for test in local.ci_test_results : test.passed]) &&
      alltrue([for test in local.platform_test_results : test.passed])
    ) ? 0 : 1
  }
}

# Create CI/CD test report in JUnit XML format
resource "pyvider_file_content" "junit_test_report" {
  filename = "/tmp/private_state_junit_report.xml"
  content = join("\n", [
    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
    "<testsuites name=\"PrivateStateVerification\" tests=\"${local.ci_summary.overall_tests_passed + local.ci_summary.overall_tests_failed}\" failures=\"${local.ci_summary.overall_tests_failed}\" time=\"${sum([for test in local.ci_test_results : test.duration])}\" timestamp=\"${timestamp()}\">",
    "  <testsuite name=\"MatrixTests\" tests=\"${local.ci_summary.total_matrix_tests}\" failures=\"${local.ci_summary.matrix_tests_failed}\" time=\"${sum([for test in local.ci_test_results : test.duration])}\">",
    join("\n", [
      for test_name, test in local.ci_test_results :
      test.passed ?
      "    <testcase name=\"${test_name}\" classname=\"PrivateStateVerifier.MatrixTests\" time=\"${test.duration}\" />" :
      "    <testcase name=\"${test_name}\" classname=\"PrivateStateVerifier.MatrixTests\" time=\"${test.duration}\">\n      <failure message=\"Expected '${test.expected}' but got '${test.output}'\" type=\"AssertionError\">\n        Test: ${test.description}\n        Priority: ${test.priority}\n        Input: ${test.input}\n        Expected: ${test.expected}\n        Actual: ${test.output}\n      </failure>\n    </testcase>"
    ]),
    "  </testsuite>",
    "  <testsuite name=\"PlatformTests\" tests=\"${local.ci_summary.total_platform_tests}\" failures=\"${local.ci_summary.platform_tests_failed}\" time=\"${local.ci_summary.total_platform_tests}\">",
    join("\n", [
      for test_name, test in local.platform_test_results :
      test.passed ?
      "    <testcase name=\"${test_name}\" classname=\"PrivateStateVerifier.PlatformTests\" time=\"1\" />" :
      "    <testcase name=\"${test_name}\" classname=\"PrivateStateVerifier.PlatformTests\" time=\"1\">\n      <failure message=\"Expected '${test.expected}' but got '${test.output}'\" type=\"AssertionError\">\n        Platform: ${test.platform}\n        Input: ${test.input}\n        Expected: ${test.expected}\n        Actual: ${test.output}\n      </failure>\n    </testcase>"
    ]),
    "  </testsuite>",
    "</testsuites>"
  ])
}

# Create CI/CD pipeline configuration files
resource "pyvider_file_content" "github_actions_workflow" {
  filename = "/tmp/github_actions_private_state_test.yml"
  content = yamlencode({
    name = "Private State Verification"
    on = {
      push = {
        branches = ["main", "develop"]
      }
      pull_request = {
        branches = ["main"]
      }
    }

    jobs = {
      private_state_test = {
        "runs-on" = "ubuntu-latest"
        steps = [
          {
            name = "Checkout"
            uses = "actions/checkout@v3"
          },
          {
            name = "Setup Terraform"
            uses = "hashicorp/setup-terraform@v2"
            with = {
              terraform_version = "1.5.0"
            }
          },
          {
            name = "Initialize Terraform"
            run = "terraform init"
          },
          {
            name = "Run Private State Tests"
            run = join("\n", [
              "terraform plan -var=\"ci_environment=github-actions\" -var=\"build_number=${{ github.run_number }}\"",
              "terraform apply -auto-approve -var=\"ci_environment=github-actions\" -var=\"build_number=${{ github.run_number }}\"",
            ])
            env = {
              TF_LOG = "INFO"
            }
          },
          {
            name = "Validate Test Results"
            run = join("\n", [
              "if [ \"${local.ci_summary.ci_status}\" = \"success\" ]; then",
              "  echo \"✅ All private state tests passed\"",
              "  exit 0",
              "else",
              "  echo \"❌ Private state tests failed\"",
              "  echo \"Critical failures: ${local.ci_summary.critical_failures}\"",
              "  exit 1",
              "fi"
            ])
          }
        ]
      }
    }
  })
}

# Create Jenkins pipeline configuration
resource "pyvider_file_content" "jenkins_pipeline" {
  filename = "/tmp/Jenkinsfile.private_state_test"
  content = join("\n", [
    "pipeline {",
    "    agent any",
    "    ",
    "    environment {",
    "        CI_ENVIRONMENT = '${var.ci_environment}'",
    "        BUILD_NUMBER = '${var.build_number}'",
    "        TF_LOG = 'INFO'",
    "    }",
    "    ",
    "    stages {",
    "        stage('Initialize') {",
    "            steps {",
    "                echo 'Initializing Private State Verification Tests'",
    "                sh 'terraform init'",
    "            }",
    "        }",
    "        ",
    "        stage('Plan Tests') {",
    "            steps {",
    "                echo 'Planning private state verification tests'",
    "                sh 'terraform plan -var=\"ci_environment=jenkins\" -var=\"build_number=${BUILD_NUMBER}\"'",
    "            }",
    "        }",
    "        ",
    "        stage('Execute Tests') {",
    "            steps {",
    "                echo 'Executing private state verification tests'",
    "                sh 'terraform apply -auto-approve -var=\"ci_environment=jenkins\" -var=\"build_number=${BUILD_NUMBER}\"'",
    "            }",
    "        }",
    "        ",
    "        stage('Validate Results') {",
    "            steps {",
    "                script {",
    "                    if ('${local.ci_summary.ci_status}' == 'success') {",
    "                        echo '✅ All private state tests passed'",
    "                        currentBuild.result = 'SUCCESS'",
    "                    } else {",
    "                        echo '❌ Private state tests failed'",
    "                        echo 'Critical failures: ${local.ci_summary.critical_failures}'",
    "                        currentBuild.result = 'FAILURE'",
    "                        error('Private state verification tests failed')",
    "                    }",
    "                }",
    "            }",
    "        }",
    "    }",
    "    ",
    "    post {",
    "        always {",
    "            echo 'Cleaning up test resources'",
    "            sh 'terraform destroy -auto-approve -var=\"ci_environment=jenkins\" -var=\"build_number=${BUILD_NUMBER}\" || true'",
    "        }",
    "        success {",
    "            echo 'Private state verification completed successfully'",
    "        }",
    "        failure {",
    "            echo 'Private state verification failed - check logs for details'",
    "        }",
    "    }",
    "}"
  ])
}

# Create comprehensive CI/CD test report
resource "pyvider_file_content" "cicd_test_report" {
  filename = "/tmp/cicd_private_state_test_report.json"
  content = jsonencode({
    test_execution = {
      timestamp = timestamp()
      ci_environment = var.ci_environment
      build_number = var.build_number
      test_suite = var.test_suite
      duration_seconds = sum([for test in local.ci_test_results : test.duration])
    }

    test_matrix_results = local.ci_test_results
    platform_test_results = local.platform_test_results

    summary = local.ci_summary

    test_categories = {
      critical_tests = {
        total = length([for test in local.ci_test_results : test if test.priority == "critical"])
        passed = length([for test in local.ci_test_results : test if test.priority == "critical" && test.passed])
        failed = length([for test in local.ci_test_results : test if test.priority == "critical" && !test.passed])
      }
      high_priority_tests = {
        total = length([for test in local.ci_test_results : test if test.priority == "high"])
        passed = length([for test in local.ci_test_results : test if test.priority == "high" && test.passed])
        failed = length([for test in local.ci_test_results : test if test.priority == "high" && !test.passed])
      }
      medium_priority_tests = {
        total = length([for test in local.ci_test_results : test if test.priority == "medium"])
        passed = length([for test in local.ci_test_results : test if test.priority == "medium" && test.passed])
        failed = length([for test in local.ci_test_results : test if test.priority == "medium" && !test.passed])
      }
    }

    platform_compatibility = {
      for platform_name, result in local.platform_test_results :
      platform_name => {
        compatible = result.passed
        platform = result.platform
        test_result = result.passed ? "pass" : "fail"
      }
    }

    quality_gates = {
      critical_tests_pass = length([for test in local.ci_test_results : test if test.priority == "critical" && !test.passed]) == 0
      high_priority_tests_pass = length([for test in local.ci_test_results : test if test.priority == "high" && !test.passed]) == 0
      platform_compatibility_pass = alltrue([for test in local.platform_test_results : test.passed])
      overall_quality_gate = local.ci_summary.all_tests_passed
    }

    recommendations = local.ci_summary.all_tests_passed ? [
      "✅ All CI/CD tests passed - ready for deployment",
      "✅ Private state encryption working correctly across platforms",
      "🚀 Proceed with release pipeline",
      "📊 Monitor production deployment"
    ] : concat([
      "❌ CI/CD tests failed - deployment blocked",
      "🔧 Fix failing tests before proceeding"
    ], local.ci_summary.critical_failures > 0 ? [
      "🚨 Critical failures detected - immediate attention required"
    ] : [], [
      "📋 Review test results and implement fixes",
      "🔄 Re-run tests after remediation"
    ])

    artifacts = {
      junit_report = pyvider_file_content.junit_test_report.filename
      github_workflow = pyvider_file_content.github_actions_workflow.filename
      jenkins_pipeline = pyvider_file_content.jenkins_pipeline.filename
      test_report = pyvider_file_content.cicd_test_report.filename
    }
  })
}

output "cicd_testing_results" {
  description = "CI/CD integration testing results for private state verification"
  value = {
    execution_summary = {
      ci_environment = var.ci_environment
      build_number = var.build_number
      test_suite_name = var.test_suite.name
      execution_status = local.ci_summary.ci_status
      exit_code = local.ci_summary.exit_code
    }

    test_metrics = {
      total_tests = local.ci_summary.overall_tests_passed + local.ci_summary.overall_tests_failed
      passed_tests = local.ci_summary.overall_tests_passed
      failed_tests = local.ci_summary.overall_tests_failed
      success_rate = local.ci_summary.overall_tests_failed == 0 ? 100 : (local.ci_summary.overall_tests_passed / (local.ci_summary.overall_tests_passed + local.ci_summary.overall_tests_failed)) * 100
    }

    test_breakdown = {
      matrix_tests = {
        total = local.ci_summary.total_matrix_tests
        passed = local.ci_summary.matrix_tests_passed
        failed = local.ci_summary.matrix_tests_failed
      }
      platform_tests = {
        total = local.ci_summary.total_platform_tests
        passed = local.ci_summary.platform_tests_passed
        failed = local.ci_summary.platform_tests_failed
      }
    }

    quality_gates = {
      critical_tests_pass = local.ci_summary.critical_failures == 0
      all_tests_pass = local.ci_summary.all_tests_passed
      deployment_approved = local.ci_summary.all_tests_passed
    }

    platform_compatibility = {
      for platform_name, result in local.platform_test_results :
      platform_name => result.passed
    }

    artifacts_generated = [
      pyvider_file_content.junit_test_report.filename,
      pyvider_file_content.github_actions_workflow.filename,
      pyvider_file_content.jenkins_pipeline.filename,
      pyvider_file_content.cicd_test_report.filename
    ]
  }
}


# === Data Sources ===

# provider_config_reader
# Basic provider configuration reader examples

# Example 1: Read current provider configuration
data "pyvider_provider_config_reader" "current" {}

# Example 2: Use provider configuration in file creation
resource "pyvider_file_content" "provider_summary" {
  filename = "/tmp/provider_config_summary.txt"
  content = join("\n", [
    "=== Provider Configuration Summary ===",
    "",
    "API Endpoint: ${data.pyvider_provider_config_reader.current.api_endpoint != null ? data.pyvider_provider_config_reader.current.api_endpoint : "Not configured"}",
    "API Timeout: ${data.pyvider_provider_config_reader.current.api_timeout != null ? "${data.pyvider_provider_config_reader.current.api_timeout} seconds" : "Default"}",
    "API Retries: ${data.pyvider_provider_config_reader.current.api_retries != null ? data.pyvider_provider_config_reader.current.api_retries : "Default"}",
    "TLS Verification: ${data.pyvider_provider_config_reader.current.api_insecure_skip_verify != null ? (data.pyvider_provider_config_reader.current.api_insecure_skip_verify ? "DISABLED" : "ENABLED") : "Default (enabled)"}",
    "Authentication: ${data.pyvider_provider_config_reader.current.api_token != null ? "Token configured" : "No authentication"}",
    "Custom Headers: ${data.pyvider_provider_config_reader.current.api_headers != null ? length(data.pyvider_provider_config_reader.current.api_headers) : 0} headers",
    "",
    "Generated at: ${timestamp()}"
  ])
}

# Example 3: Create environment detection based on provider config
locals {
  # Determine environment from API endpoint
  detected_environment = (
    data.pyvider_provider_config_reader.current.api_endpoint != null ? (
      can(regex("localhost|127\\.0\\.0\\.1", data.pyvider_provider_config_reader.current.api_endpoint)) ? "local" :
      can(regex("dev|development", data.pyvider_provider_config_reader.current.api_endpoint)) ? "development" :
      can(regex("test|testing", data.pyvider_provider_config_reader.current.api_endpoint)) ? "testing" :
      can(regex("staging|stage", data.pyvider_provider_config_reader.current.api_endpoint)) ? "staging" :
      can(regex("prod|production", data.pyvider_provider_config_reader.current.api_endpoint)) ? "production" :
      "unknown"
    ) : "unconfigured"
  )

  # Configuration analysis
  config_analysis = {
    endpoint_configured = data.pyvider_provider_config_reader.current.api_endpoint != null
    auth_configured     = data.pyvider_provider_config_reader.current.api_token != null
    has_custom_headers  = data.pyvider_provider_config_reader.current.api_headers != null && length(data.pyvider_provider_config_reader.current.api_headers) > 0
    tls_secure         = data.pyvider_provider_config_reader.current.api_insecure_skip_verify != true

    timeout_configured = data.pyvider_provider_config_reader.current.api_timeout != null
    timeout_value     = data.pyvider_provider_config_reader.current.api_timeout
    timeout_category  = (
      data.pyvider_provider_config_reader.current.api_timeout == null ? "default" :
      data.pyvider_provider_config_reader.current.api_timeout <= 10 ? "fast" :
      data.pyvider_provider_config_reader.current.api_timeout <= 60 ? "normal" :
      data.pyvider_provider_config_reader.current.api_timeout <= 300 ? "slow" :
      "very_slow"
    )

    retries_configured = data.pyvider_provider_config_reader.current.api_retries != null
    retries_value     = data.pyvider_provider_config_reader.current.api_retries
    retries_category  = (
      data.pyvider_provider_config_reader.current.api_retries == null ? "default" :
      data.pyvider_provider_config_reader.current.api_retries == 0 ? "no_retries" :
      data.pyvider_provider_config_reader.current.api_retries <= 3 ? "conservative" :
      data.pyvider_provider_config_reader.current.api_retries <= 10 ? "aggressive" :
      "very_aggressive"
    )
  }

  # Configuration recommendations
  config_recommendations = concat(
    !local.config_analysis.endpoint_configured ? ["Configure api_endpoint in provider block"] : [],
    !local.config_analysis.auth_configured ? ["Consider configuring api_token for authentication"] : [],
    !local.config_analysis.tls_secure ? ["WARNING: TLS verification is disabled - security risk"] : [],
    local.config_analysis.timeout_category == "very_slow" ? ["Consider reducing api_timeout for better performance"] : [],
    local.config_analysis.retries_category == "very_aggressive" ? ["High retry count may cause long delays on failures"] : []
  )

  # Security assessment
  security_score = (
    (local.config_analysis.endpoint_configured && can(regex("^https://", data.pyvider_provider_config_reader.current.api_endpoint)) ? 25 : 0) +
    (local.config_analysis.auth_configured ? 25 : 0) +
    (local.config_analysis.tls_secure ? 25 : 0) +
    (!local.config_analysis.has_custom_headers || length(data.pyvider_provider_config_reader.current.api_headers) <= 5 ? 25 : 0)
  )
}

# Example 4: Create environment-specific configuration file
resource "pyvider_file_content" "environment_config" {
  filename = "/tmp/environment_config.json"
  content = jsonencode({
    detected_environment = local.detected_environment

    provider_config = {
      endpoint_url = data.pyvider_provider_config_reader.current.api_endpoint
      timeout_seconds = data.pyvider_provider_config_reader.current.api_timeout
      retry_count = data.pyvider_provider_config_reader.current.api_retries
      tls_verification = !data.pyvider_provider_config_reader.current.api_insecure_skip_verify
      authentication_enabled = data.pyvider_provider_config_reader.current.api_token != null
      custom_headers_count = data.pyvider_provider_config_reader.current.api_headers != null ? length(data.pyvider_provider_config_reader.current.api_headers) : 0
    }

    analysis = local.config_analysis

    security = {
      score = local.security_score
      level = (
        local.security_score >= 75 ? "high" :
        local.security_score >= 50 ? "medium" :
        local.security_score >= 25 ? "low" :
        "very_low"
      )
    }

    recommendations = local.config_recommendations

    timestamp = timestamp()
  })
}

# Example 5: Conditional resource creation based on provider config
resource "pyvider_file_content" "debug_info" {
  count = local.detected_environment == "development" || local.detected_environment == "local" ? 1 : 0

  filename = "/tmp/debug_info.txt"
  content = join("\n", [
    "=== DEBUG MODE ENABLED ===",
    "Environment: ${local.detected_environment}",
    "Provider endpoint: ${data.pyvider_provider_config_reader.current.api_endpoint}",
    "Timeout configuration: ${local.config_analysis.timeout_category}",
    "Retry configuration: ${local.config_analysis.retries_category}",
    "Security score: ${local.security_score}/100",
    "",
    "This file is only created in development/local environments.",
    "Generated at: ${timestamp()}"
  ])
}

resource "pyvider_file_content" "production_config" {
  count = local.detected_environment == "production" ? 1 : 0

  filename = "/tmp/production_config.txt"
  content = join("\n", [
    "=== PRODUCTION ENVIRONMENT DETECTED ===",
    "Security level: ${local.security_score >= 75 ? "ACCEPTABLE" : "NEEDS IMPROVEMENT"}",
    "TLS verification: ${local.config_analysis.tls_secure ? "ENABLED" : "DISABLED - SECURITY RISK"}",
    "Authentication: ${local.config_analysis.auth_configured ? "CONFIGURED" : "NOT CONFIGURED"}",
    "",
    length(local.config_recommendations) > 0 ? "RECOMMENDATIONS:" : "Configuration looks good!",
    join("\n", [for rec in local.config_recommendations : "- ${rec}"]),
    "",
    "Generated at: ${timestamp()}"
  ])
}

# Example 6: Create API client configuration file
resource "pyvider_file_content" "api_client_config" {
  filename = "/tmp/api_client_config.yaml"
  content = yamlencode({
    api_client = {
      base_url = data.pyvider_provider_config_reader.current.api_endpoint != null ? data.pyvider_provider_config_reader.current.api_endpoint : "http://localhost:8080"

      timeout = {
        seconds = data.pyvider_provider_config_reader.current.api_timeout != null ? data.pyvider_provider_config_reader.current.api_timeout : 30
        category = local.config_analysis.timeout_category
      }

      retry_policy = {
        max_attempts = data.pyvider_provider_config_reader.current.api_retries != null ? data.pyvider_provider_config_reader.current.api_retries + 1 : 4
        strategy = local.config_analysis.retries_category
      }

      security = {
        verify_tls = !data.pyvider_provider_config_reader.current.api_insecure_skip_verify
        auth_required = data.pyvider_provider_config_reader.current.api_token != null
      }

      headers = data.pyvider_provider_config_reader.current.api_headers != null ? data.pyvider_provider_config_reader.current.api_headers : {}
    }

    metadata = {
      environment = local.detected_environment
      security_score = local.security_score
      config_source = "terraform_provider"
      generated_at = timestamp()
    }
  })
}

output "provider_config_analysis" {
  description = "Analysis of current provider configuration"
  value = {
    detected_environment = local.detected_environment

    configuration = {
      endpoint_configured = local.config_analysis.endpoint_configured
      auth_configured = local.config_analysis.auth_configured
      tls_secure = local.config_analysis.tls_secure
      timeout_category = local.config_analysis.timeout_category
      retries_category = local.config_analysis.retries_category
    }

    security = {
      score = local.security_score
      level = (
        local.security_score >= 75 ? "high" :
        local.security_score >= 50 ? "medium" :
        local.security_score >= 25 ? "low" :
        "very_low"
      )
    }

    recommendations_count = length(local.config_recommendations)

    files_created = concat(
      [
        pyvider_file_content.provider_summary.filename,
        pyvider_file_content.environment_config.filename,
        pyvider_file_content.api_client_config.filename
      ],
      local.detected_environment == "development" || local.detected_environment == "local" ? [
        pyvider_file_content.debug_info[0].filename
      ] : [],
      local.detected_environment == "production" ? [
        pyvider_file_content.production_config[0].filename
      ] : []
    )
  }
}

# env_variables
# Sensitive variable handling examples

# Read a mix of sensitive and non-sensitive variables
data "pyvider_env_variables" "app_credentials" {
  keys = [
    "DATABASE_URL",     # Sensitive - contains credentials
    "API_SECRET_KEY",   # Sensitive - secret key
    "JWT_SIGNING_KEY",  # Sensitive - cryptographic key
    "APP_NAME",         # Not sensitive - application name
    "APP_VERSION",      # Not sensitive - version info
    "LOG_LEVEL"         # Not sensitive - logging configuration
  ]

  # Mark which variables should be treated as sensitive
  sensitive_keys = [
    "DATABASE_URL",
    "API_SECRET_KEY",
    "JWT_SIGNING_KEY"
  ]
}

# Read environment variables with prefix filtering for secrets
data "pyvider_env_variables" "secrets" {
  prefix = "SECRET_"
  # All variables with SECRET_ prefix are treated as sensitive
  sensitive_keys = [for k in keys(data.pyvider_env_variables.secrets.all_environment) : k if can(regex("^SECRET_", k))]
}

# Read configuration with selective sensitivity
data "pyvider_env_variables" "oauth_config" {
  prefix = "OAUTH_"
  sensitive_keys = [
    "OAUTH_CLIENT_SECRET",
    "OAUTH_PRIVATE_KEY"
    # OAUTH_CLIENT_ID and OAUTH_REDIRECT_URI are not sensitive
  ]
}

# Example of safely using sensitive variables
locals {
  # Non-sensitive configuration can be used directly
  app_metadata = {
    name     = lookup(data.pyvider_env_variables.app_credentials.values, "APP_NAME", "unknown-app")
    version  = lookup(data.pyvider_env_variables.app_credentials.values, "APP_VERSION", "0.0.0")
    log_level = lookup(data.pyvider_env_variables.app_credentials.values, "LOG_LEVEL", "INFO")
  }

  # For sensitive data, we need to be careful about how we use it
  # We can't directly interpolate sensitive values into strings
  has_database_url = contains(keys(data.pyvider_env_variables.app_credentials.sensitive_values), "DATABASE_URL")
  has_api_key = contains(keys(data.pyvider_env_variables.app_credentials.sensitive_values), "API_SECRET_KEY")

  # OAuth configuration (mixed sensitive/non-sensitive)
  oauth_public_config = {
    client_id = lookup(data.pyvider_env_variables.oauth_config.values, "OAUTH_CLIENT_ID", "")
    redirect_uri = lookup(data.pyvider_env_variables.oauth_config.values, "OAUTH_REDIRECT_URI", "")
    enabled = lookup(data.pyvider_env_variables.oauth_config.values, "OAUTH_ENABLED", "false") == "true"
  }
}

# Create a non-sensitive configuration file
resource "pyvider_file_content" "public_config" {
  filename = "/tmp/public_config.yaml"
  content = yamlencode({
    application = local.app_metadata
    oauth = local.oauth_public_config
    security = {
      has_database_credentials = local.has_database_url
      has_api_key = local.has_api_key
      total_secrets = length(data.pyvider_env_variables.app_credentials.sensitive_values)
    }
    generated_at = timestamp()
  })
}

# Create a template file that references sensitive variables
# Note: The actual sensitive values won't be exposed in the file content
resource "pyvider_file_content" "app_config_template" {
  filename = "/tmp/app_config_template.env"
  content = join("\n", [
    "# Application Configuration Template",
    "# This file shows which environment variables are expected",
    "",
    "# Application Metadata",
    "APP_NAME=${local.app_metadata.name}",
    "APP_VERSION=${local.app_metadata.version}",
    "LOG_LEVEL=${local.app_metadata.log_level}",
    "",
    "# Sensitive Variables (values not shown)",
    "# These must be set in the environment:",
    local.has_database_url ? "# DATABASE_URL=<configured>" : "# DATABASE_URL=<not configured>",
    local.has_api_key ? "# API_SECRET_KEY=<configured>" : "# API_SECRET_KEY=<not configured>",
    "",
    "# OAuth Configuration",
    "OAUTH_CLIENT_ID=${local.oauth_public_config.client_id}",
    "OAUTH_REDIRECT_URI=${local.oauth_public_config.redirect_uri}",
    "OAUTH_ENABLED=${local.oauth_public_config.enabled}",
    "# OAUTH_CLIENT_SECRET=<sensitive>",
    "# OAUTH_PRIVATE_KEY=<sensitive>",
    "",
    "# Configuration generated at: ${timestamp()}"
  ])
}

# Example of secure credential validation
locals {
  # Check if required sensitive variables are present
  required_secrets = ["DATABASE_URL", "API_SECRET_KEY"]
  missing_secrets = [
    for secret in local.required_secrets :
    secret if !contains(keys(data.pyvider_env_variables.app_credentials.sensitive_values), secret)
  ]

  # Validate credential formats (without exposing values)
  credential_validation = {
    database_url_format_valid = local.has_database_url ? (
      can(regex("^(postgresql|mysql|sqlite)://",
        data.pyvider_env_variables.app_credentials.sensitive_values["DATABASE_URL"]
      ))
    ) : false

    api_key_length_valid = local.has_api_key ? (
      length(data.pyvider_env_variables.app_credentials.sensitive_values["API_SECRET_KEY"]) >= 32
    ) : false
  }
}

# Create a security report (without exposing sensitive values)
resource "pyvider_file_content" "security_report" {
  filename = "/tmp/security_report.json"
  content = jsonencode({
    security_assessment = {
      total_variables_checked = length(data.pyvider_env_variables.app_credentials.keys)
      sensitive_variables_found = length(data.pyvider_env_variables.app_credentials.sensitive_values)
      non_sensitive_variables = length(data.pyvider_env_variables.app_credentials.values)

      required_secrets = {
        expected = local.required_secrets
        missing = local.missing_secrets
        all_present = length(local.missing_secrets) == 0
      }

      credential_validation = local.credential_validation

      oauth_config = {
        public_settings = local.oauth_public_config
        sensitive_keys_present = {
          client_secret = contains(keys(data.pyvider_env_variables.oauth_config.sensitive_values), "OAUTH_CLIENT_SECRET")
          private_key = contains(keys(data.pyvider_env_variables.oauth_config.sensitive_values), "OAUTH_PRIVATE_KEY")
        }
      }

      recommendations = concat(
        length(local.missing_secrets) > 0 ? ["Set missing environment variables: ${join(", ", local.missing_secrets)}"] : [],
        !local.credential_validation.database_url_format_valid ? ["Check DATABASE_URL format"] : [],
        !local.credential_validation.api_key_length_valid ? ["API_SECRET_KEY should be at least 32 characters"] : []
      )
    }
    generated_at = timestamp()
  })
}

# Example of conditional resource creation based on sensitive variables
resource "pyvider_file_content" "database_status" {
  count = local.has_database_url ? 1 : 0

  filename = "/tmp/database_available.txt"
  content = join("\n", [
    "Database configuration detected",
    "Application: ${local.app_metadata.name}",
    "Version: ${local.app_metadata.version}",
    "Database URL is configured and available",
    "URL format validation: ${local.credential_validation.database_url_format_valid ? "PASSED" : "FAILED"}",
    "",
    "Generated at: ${timestamp()}"
  ])
}

resource "pyvider_file_content" "no_database_warning" {
  count = !local.has_database_url ? 1 : 0

  filename = "/tmp/no_database_warning.txt"
  content = join("\n", [
    "WARNING: No database configuration found",
    "Application: ${local.app_metadata.name}",
    "Please set the DATABASE_URL environment variable",
    "",
    "Generated at: ${timestamp()}"
  ])
}

output "sensitive_variable_handling" {
  description = "Example of handling sensitive environment variables"
  value = {
    application_info = local.app_metadata

    security_status = {
      total_secrets_configured = length(data.pyvider_env_variables.app_credentials.sensitive_values)
      required_secrets_present = length(local.missing_secrets) == 0
      missing_secrets_count = length(local.missing_secrets)
      # Note: We don't expose the actual missing secret names in output
    }

    oauth_status = {
      public_config = local.oauth_public_config
      has_client_secret = contains(keys(data.pyvider_env_variables.oauth_config.sensitive_values), "OAUTH_CLIENT_SECRET")
      has_private_key = contains(keys(data.pyvider_env_variables.oauth_config.sensitive_values), "OAUTH_PRIVATE_KEY")
    }

    validation_results = local.credential_validation

    files_created = {
      public_config = pyvider_file_content.public_config.filename
      template = pyvider_file_content.app_config_template.filename
      security_report = pyvider_file_content.security_report.filename
      database_status = local.has_database_url ? pyvider_file_content.database_status[0].filename : null
      no_database_warning = !local.has_database_url ? pyvider_file_content.no_database_warning[0].filename : null
    }
  }

  # Mark this output as sensitive since it contains information about sensitive variables
  sensitive = true
}

# lens_jq
# Complex JQ transformations for advanced data processing

# Example 1: Multi-level data processing
data "pyvider_lens_jq" "company_analysis" {
  json_input = jsonencode({
    company = "TechCorp"
    departments = [
      {
        name = "Engineering"
        budget = 2500000
        employees = [
          { name = "Alice", role = "Senior Engineer", salary = 120000, skills = ["Python", "Go", "Kubernetes"] },
          { name = "Bob", role = "Engineer", salary = 95000, skills = ["JavaScript", "React", "Node.js"] },
          { name = "Carol", role = "Tech Lead", salary = 140000, skills = ["Python", "AWS", "Docker"] }
        ]
      },
      {
        name = "Marketing"
        budget = 1200000
        employees = [
          { name = "Dave", role = "Marketing Manager", salary = 85000, skills = ["SEO", "Analytics", "Content"] },
          { name = "Eve", role = "Content Creator", salary = 65000, skills = ["Writing", "Design", "Social Media"] }
        ]
      },
      {
        name = "Sales"
        budget = 1800000
        employees = [
          { name = "Frank", role = "Sales Director", salary = 110000, skills = ["B2B Sales", "CRM", "Negotiation"] },
          { name = "Grace", role = "Account Manager", salary = 75000, skills = ["Customer Relations", "Salesforce"] }
        ]
      }
    ]
  })
  query = ".departments | map({
    department: .name,
    employee_count: (.employees | length),
    total_salary_cost: ([.employees[].salary] | add),
    avg_salary: (([.employees[].salary] | add) / (.employees | length)),
    budget_utilization: ((([.employees[].salary] | add) / .budget) * 100),
    skill_diversity: ([.employees[].skills[]] | unique | length),
    senior_roles: ([.employees[] | select(.role | contains(\"Senior\") or contains(\"Lead\") or contains(\"Director\") or contains(\"Manager\"))] | length)
  })"
}

# Example 2: Time series data processing
data "pyvider_lens_jq" "metrics_analysis" {
  json_input = jsonencode({
    metrics = [
      { timestamp = "2024-01-01T00:00:00Z", cpu_usage = 45.2, memory_usage = 67.8, requests = 1250 },
      { timestamp = "2024-01-01T01:00:00Z", cpu_usage = 52.1, memory_usage = 72.1, requests = 1380 },
      { timestamp = "2024-01-01T02:00:00Z", cpu_usage = 38.9, memory_usage = 65.2, requests = 1100 },
      { timestamp = "2024-01-01T03:00:00Z", cpu_usage = 61.7, memory_usage = 78.9, requests = 1520 },
      { timestamp = "2024-01-01T04:00:00Z", cpu_usage = 44.3, memory_usage = 69.4, requests = 1290 }
    ]
  })
  query = "{
    total_hours: (.metrics | length),
    cpu_stats: {
      average: (([.metrics[].cpu_usage] | add) / (.metrics | length)),
      max: ([.metrics[].cpu_usage] | max),
      min: ([.metrics[].cpu_usage] | min),
      above_50: ([.metrics[] | select(.cpu_usage > 50)] | length)
    },
    memory_stats: {
      average: (([.metrics[].memory_usage] | add) / (.metrics | length)),
      max: ([.metrics[].memory_usage] | max),
      min: ([.metrics[].memory_usage] | min),
      above_75: ([.metrics[] | select(.memory_usage > 75)] | length)
    },
    request_stats: {
      total: ([.metrics[].requests] | add),
      average: (([.metrics[].requests] | add) / (.metrics | length)),
      peak_hour: (.metrics | max_by(.requests) | .timestamp),
      low_hour: (.metrics | min_by(.requests) | .timestamp)
    },
    alerts: [
      (.metrics[] | select(.cpu_usage > 60) | \"High CPU at \" + .timestamp),
      (.metrics[] | select(.memory_usage > 75) | \"High Memory at \" + .timestamp)
    ]
  }"
}

# Example 3: Configuration transformation and validation
data "pyvider_lens_jq" "config_processor" {
  json_input = jsonencode({
    environments = {
      development = {
        api_endpoint = "https://dev-api.example.com"
        database_url = "postgres://dev-db:5432/app"
        redis_url = "redis://dev-cache:6379"
        log_level = "debug"
        replicas = 1
        resources = {
          cpu = "100m"
          memory = "256Mi"
        }
      }
      staging = {
        api_endpoint = "https://staging-api.example.com"
        database_url = "postgres://staging-db:5432/app"
        redis_url = "redis://staging-cache:6379"
        log_level = "info"
        replicas = 2
        resources = {
          cpu = "500m"
          memory = "512Mi"
        }
      }
      production = {
        api_endpoint = "https://api.example.com"
        database_url = "postgres://prod-db:5432/app"
        redis_url = "redis://prod-cache:6379"
        log_level = "warn"
        replicas = 5
        resources = {
          cpu = "1000m"
          memory = "1Gi"
        }
      }
    }
  })
  query = ".environments | to_entries | map({
    environment: .key,
    config: .value,
    security_score: (
      (if (.value.api_endpoint | startswith(\"https://\")) then 25 else 0 end) +
      (if (.value.database_url | contains(\"ssl\")) then 25 else 10 end) +
      (if (.value.log_level == \"warn\" or .value.log_level == \"error\") then 25 else 0 end) +
      (if (.value.replicas > 1) then 25 else 0 end)
    ),
    resource_tier: (
      if (.value.resources.memory | test(\"Gi\")) then \"high\"
      elif (.value.resources.memory | test(\"512Mi\")) then \"medium\"
      else \"low\"
      end
    ),
    recommendations: [
      (if (.value.log_level == \"debug\" and .key != \"development\") then \"Consider changing log level from debug\" else empty end),
      (if (.value.replicas < 2 and .key == \"production\") then \"Production should have multiple replicas\" else empty end),
      (if (.value.api_endpoint | startswith(\"http://\")) then \"Use HTTPS for secure communication\" else empty end)
    ]
  })"
}

# Example 4: Data aggregation and grouping
data "pyvider_lens_jq" "transaction_analysis" {
  json_input = jsonencode([
    { id = "tx1", amount = 150.50, currency = "USD", category = "food", date = "2024-01-15", user_id = "user1" },
    { id = "tx2", amount = 75.25, currency = "USD", category = "transport", date = "2024-01-15", user_id = "user2" },
    { id = "tx3", amount = 200.00, currency = "EUR", category = "food", date = "2024-01-16", user_id = "user1" },
    { id = "tx4", amount = 50.75, currency = "USD", category = "entertainment", date = "2024-01-16", user_id = "user3" },
    { id = "tx5", amount = 120.30, currency = "EUR", category = "food", date = "2024-01-17", user_id = "user2" },
    { id = "tx6", amount = 90.45, currency = "USD", category = "transport", date = "2024-01-17", user_id = "user1" }
  ])
  query = "{
    by_category: (
      group_by(.category) | map({
        category: .[0].category,
        total_transactions: length,
        total_amount_usd: ([.[] | select(.currency == \"USD\") | .amount] | add // 0),
        total_amount_eur: ([.[] | select(.currency == \"EUR\") | .amount] | add // 0),
        avg_amount: (([.[].amount] | add) / length),
        users: ([.[].user_id] | unique)
      })
    ),
    by_currency: (
      group_by(.currency) | map({
        currency: .[0].currency,
        transaction_count: length,
        total_amount: ([.[].amount] | add),
        avg_amount: (([.[].amount] | add) / length),
        categories: ([.[].category] | unique)
      })
    ),
    by_date: (
      group_by(.date) | map({
        date: .[0].date,
        transaction_count: length,
        daily_total: ([.[].amount] | add),
        unique_users: ([.[].user_id] | unique | length)
      })
    ),
    summary: {
      total_transactions: length,
      unique_users: ([.[].user_id] | unique | length),
      date_range: {
        first: (map(.date) | sort | first),
        last: (map(.date) | sort | last)
      },
      largest_transaction: (max_by(.amount) | {id, amount, category}),
      most_active_user: (
        group_by(.user_id) | map({user: .[0].user_id, count: length}) | max_by(.count) | .user
      )
    }
  }"
}

# Create detailed analysis files
resource "pyvider_file_content" "company_analysis_report" {
  filename = "/tmp/company_analysis.json"
  content = jsonencode({
    timestamp = timestamp()
    analysis = jsondecode(data.pyvider_lens_jq.company_analysis.result)
    summary = {
      total_departments = length(jsondecode(data.pyvider_lens_jq.company_analysis.result))
      highest_budget_utilization = max([
        for dept in jsondecode(data.pyvider_lens_jq.company_analysis.result) :
        dept.budget_utilization
      ]...)
      most_diverse_skills = max([
        for dept in jsondecode(data.pyvider_lens_jq.company_analysis.result) :
        dept.skill_diversity
      ]...)
    }
  })
}

resource "pyvider_file_content" "metrics_dashboard" {
  filename = "/tmp/metrics_dashboard.txt"
  content = join("\n", [
    "=== System Metrics Dashboard ===",
    "",
    "Monitoring Period: ${jsondecode(data.pyvider_lens_jq.metrics_analysis.result).total_hours} hours",
    "",
    "CPU Performance:",
    "- Average: ${jsondecode(data.pyvider_lens_jq.metrics_analysis.result).cpu_stats.average}%",
    "- Peak: ${jsondecode(data.pyvider_lens_jq.metrics_analysis.result).cpu_stats.max}%",
    "- High Usage Hours: ${jsondecode(data.pyvider_lens_jq.metrics_analysis.result).cpu_stats.above_50}",
    "",
    "Memory Performance:",
    "- Average: ${jsondecode(data.pyvider_lens_jq.metrics_analysis.result).memory_stats.average}%",
    "- Peak: ${jsondecode(data.pyvider_lens_jq.metrics_analysis.result).memory_stats.max}%",
    "- Critical Hours: ${jsondecode(data.pyvider_lens_jq.metrics_analysis.result).memory_stats.above_75}",
    "",
    "Request Statistics:",
    "- Total Requests: ${jsondecode(data.pyvider_lens_jq.metrics_analysis.result).request_stats.total}",
    "- Average per Hour: ${jsondecode(data.pyvider_lens_jq.metrics_analysis.result).request_stats.average}",
    "- Peak Hour: ${jsondecode(data.pyvider_lens_jq.metrics_analysis.result).request_stats.peak_hour}",
    "",
    "Alerts Generated: ${length(jsondecode(data.pyvider_lens_jq.metrics_analysis.result).alerts)}",
    "",
    "Generated at: ${timestamp()}"
  ])
}

# Output comprehensive results
output "complex_jq_analysis" {
  description = "Complex JQ transformation results"
  value = {
    company_analysis = {
      departments_analyzed = length(jsondecode(data.pyvider_lens_jq.company_analysis.result))
      total_employees = sum([
        for dept in jsondecode(data.pyvider_lens_jq.company_analysis.result) :
        dept.employee_count
      ])
    }

    metrics_summary = {
      monitoring_hours = jsondecode(data.pyvider_lens_jq.metrics_analysis.result).total_hours
      cpu_avg = jsondecode(data.pyvider_lens_jq.metrics_analysis.result).cpu_stats.average
      memory_avg = jsondecode(data.pyvider_lens_jq.metrics_analysis.result).memory_stats.average
      total_requests = jsondecode(data.pyvider_lens_jq.metrics_analysis.result).request_stats.total
      alerts_generated = length(jsondecode(data.pyvider_lens_jq.metrics_analysis.result).alerts)
    }

    config_environments = length(jsondecode(data.pyvider_lens_jq.config_processor.result))

    transaction_summary = {
      total_transactions = jsondecode(data.pyvider_lens_jq.transaction_analysis.result).summary.total_transactions
      unique_users = jsondecode(data.pyvider_lens_jq.transaction_analysis.result).summary.unique_users
      categories_found = length(jsondecode(data.pyvider_lens_jq.transaction_analysis.result).by_category)
      currencies_found = length(jsondecode(data.pyvider_lens_jq.transaction_analysis.result).by_currency)
    }

    files_created = [
      pyvider_file_content.company_analysis_report.filename,
      pyvider_file_content.metrics_dashboard.filename
    ]
  }
}

# http_api
# Basic HTTP API usage examples

# Example 1: Simple GET request
data "pyvider_http_api" "simple_get" {
  url = "https://httpbin.org/get"
}

# Example 2: GET request with query parameters in URL
data "pyvider_http_api" "with_params" {
  url = "https://httpbin.org/get?param1=value1&param2=value2"
}

# Example 3: GET request with custom headers
data "pyvider_http_api" "with_headers" {
  url = "https://httpbin.org/headers"
  headers = {
    "User-Agent"    = "Terraform-Pyvider/1.0"
    "Accept"        = "application/json"
    "Custom-Header" = "custom-value"
  }
}

# Example 4: Request with custom timeout
data "pyvider_http_api" "with_timeout" {
  url     = "https://httpbin.org/delay/2"
  timeout = 10  # 10 seconds
}

# Example 5: HEAD request to check resource existence
data "pyvider_http_api" "head_check" {
  url    = "https://httpbin.org/status/200"
  method = "HEAD"
}

# Example 6: Real-world example - GitHub API
data "pyvider_http_api" "github_user" {
  url = "https://api.github.com/users/octocat"
  headers = {
    "Accept"     = "application/vnd.github.v3+json"
    "User-Agent" = "Terraform-Provider-Example"
  }
}

# Example 7: JSONPlaceholder API for testing
data "pyvider_http_api" "json_placeholder" {
  url = "https://jsonplaceholder.typicode.com/posts/1"
  headers = {
    "Accept" = "application/json"
  }
}

# Process API responses
locals {
  # Parse JSON responses
  github_user = can(jsondecode(data.pyvider_http_api.github_user.response_body)) ?
    jsondecode(data.pyvider_http_api.github_user.response_body) : {}

  json_post = can(jsondecode(data.pyvider_http_api.json_placeholder.response_body)) ?
    jsondecode(data.pyvider_http_api.json_placeholder.response_body) : {}

  # Extract specific information
  user_info = {
    name         = lookup(local.github_user, "name", "Unknown")
    public_repos = lookup(local.github_user, "public_repos", 0)
    followers    = lookup(local.github_user, "followers", 0)
    company      = lookup(local.github_user, "company", "None")
  }

  post_info = {
    title  = lookup(local.json_post, "title", "No title")
    body   = lookup(local.json_post, "body", "No content")
    userId = lookup(local.json_post, "userId", 0)
  }

  # Check response success
  requests_status = {
    simple_get = {
      success       = data.pyvider_http_api.simple_get.status_code == 200
      response_time = data.pyvider_http_api.simple_get.response_time_ms
      content_type  = data.pyvider_http_api.simple_get.content_type
    }

    github_api = {
      success       = data.pyvider_http_api.github_user.status_code == 200
      response_time = data.pyvider_http_api.github_user.response_time_ms
      headers_count = data.pyvider_http_api.github_user.header_count
    }

    head_request = {
      success       = data.pyvider_http_api.head_check.status_code == 200
      response_time = data.pyvider_http_api.head_check.response_time_ms
      has_body      = data.pyvider_http_api.head_check.response_body != null
    }
  }
}

# Create files with API responses
resource "pyvider_file_content" "api_responses" {
  filename = "/tmp/http_api_basic_responses.json"
  content = jsonencode({
    timestamp = timestamp()

    responses = {
      simple_get = {
        url         = data.pyvider_http_api.simple_get.url
        status_code = data.pyvider_http_api.simple_get.status_code
        success     = local.requests_status.simple_get.success
        response_time_ms = data.pyvider_http_api.simple_get.response_time_ms
        content_type = data.pyvider_http_api.simple_get.content_type
      }

      with_headers = {
        url           = data.pyvider_http_api.with_headers.url
        status_code   = data.pyvider_http_api.with_headers.status_code
        headers_count = data.pyvider_http_api.with_headers.header_count
      }

      timeout_test = {
        url           = data.pyvider_http_api.with_timeout.url
        status_code   = data.pyvider_http_api.with_timeout.status_code
        response_time = data.pyvider_http_api.with_timeout.response_time_ms
        configured_timeout = 10
      }

      head_request = {
        url         = data.pyvider_http_api.head_check.url
        method      = data.pyvider_http_api.head_check.method
        status_code = data.pyvider_http_api.head_check.status_code
        has_body    = local.requests_status.head_request.has_body
      }
    }

    parsed_data = {
      github_user = local.user_info
      sample_post = local.post_info
    }

    performance_summary = {
      total_requests = 7
      successful_requests = length([
        for status in values(local.requests_status) : status
        if status.success
      ])
      average_response_time = (
        data.pyvider_http_api.simple_get.response_time_ms +
        data.pyvider_http_api.github_user.response_time_ms +
        data.pyvider_http_api.head_check.response_time_ms
      ) / 3
    }
  })
}

# Create a simple text report
resource "pyvider_file_content" "api_report" {
  filename = "/tmp/http_api_basic_report.txt"
  content = join("\n", [
    "=== HTTP API Basic Examples Report ===",
    "",
    "=== Request Status Summary ===",
    "Simple GET: ${local.requests_status.simple_get.success ? "SUCCESS" : "FAILED"} (${data.pyvider_http_api.simple_get.status_code}) - ${data.pyvider_http_api.simple_get.response_time_ms}ms",
    "With Headers: ${data.pyvider_http_api.with_headers.status_code == 200 ? "SUCCESS" : "FAILED"} (${data.pyvider_http_api.with_headers.status_code}) - ${data.pyvider_http_api.with_headers.header_count} headers",
    "Timeout Test: ${local.requests_status.simple_get.success ? "SUCCESS" : "FAILED"} (${data.pyvider_http_api.with_timeout.status_code}) - ${data.pyvider_http_api.with_timeout.response_time_ms}ms",
    "HEAD Request: ${local.requests_status.head_request.success ? "SUCCESS" : "FAILED"} (${data.pyvider_http_api.head_check.status_code}) - No body: ${!local.requests_status.head_request.has_body}",
    "GitHub API: ${local.requests_status.github_api.success ? "SUCCESS" : "FAILED"} (${data.pyvider_http_api.github_user.status_code}) - ${data.pyvider_http_api.github_user.response_time_ms}ms",
    "",
    "=== GitHub User Information ===",
    "Name: ${local.user_info.name}",
    "Public Repos: ${local.user_info.public_repos}",
    "Followers: ${local.user_info.followers}",
    "Company: ${local.user_info.company}",
    "",
    "=== Sample Post Information ===",
    "Title: ${local.post_info.title}",
    "User ID: ${local.post_info.userId}",
    "Content Length: ${length(local.post_info.body)} characters",
    "",
    "=== Performance Metrics ===",
    "Fastest Response: ${min(data.pyvider_http_api.simple_get.response_time_ms, data.pyvider_http_api.github_user.response_time_ms, data.pyvider_http_api.head_check.response_time_ms)}ms",
    "Slowest Response: ${max(data.pyvider_http_api.simple_get.response_time_ms, data.pyvider_http_api.github_user.response_time_ms, data.pyvider_http_api.head_check.response_time_ms)}ms",
    "",
    "Report generated at: ${timestamp()}"
  ])
}

output "basic_http_api_results" {
  description = "Results from basic HTTP API calls"
  value = {
    request_summary = {
      total_requests = 7
      successful_requests = length([
        for req in [
          data.pyvider_http_api.simple_get,
          data.pyvider_http_api.with_headers,
          data.pyvider_http_api.with_timeout,
          data.pyvider_http_api.head_check,
          data.pyvider_http_api.github_user,
          data.pyvider_http_api.json_placeholder
        ] : req if req.status_code == 200
      ])
    }

    response_times = {
      simple_get   = data.pyvider_http_api.simple_get.response_time_ms
      github_api   = data.pyvider_http_api.github_user.response_time_ms
      head_request = data.pyvider_http_api.head_check.response_time_ms
    }

    parsed_data = {
      github_user = local.user_info
      sample_post = local.post_info
    }

    content_types = {
      simple_get    = data.pyvider_http_api.simple_get.content_type
      github_api    = data.pyvider_http_api.github_user.content_type
      json_placeholder = data.pyvider_http_api.json_placeholder.content_type
    }

    generated_files = [
      pyvider_file_content.api_responses.filename,
      pyvider_file_content.api_report.filename
    ]
  }
}

# file_info
# Basic file information examples

# Check a regular file
data "pyvider_file_info" "hosts_file" {
  path = "/etc/hosts"
}

# Check a directory
data "pyvider_file_info" "tmp_dir" {
  path = "/tmp"
}

# Check a potentially non-existent file
data "pyvider_file_info" "config_file" {
  path = "/etc/myapp/config.yaml"
}

# Check current working directory
data "pyvider_file_info" "current_dir" {
  path = "."
}

# Create some files to demonstrate with
resource "pyvider_local_directory" "test_dir" {
  path        = "/tmp/file_info_test"
  permissions = "0755"
}

resource "pyvider_file_content" "sample_text" {
  filename = "${pyvider_local_directory.test_dir.path}/sample.txt"
  content  = "This is a sample text file for testing file_info data source."

  depends_on = [pyvider_local_directory.test_dir]
}

resource "pyvider_file_content" "sample_json" {
  filename = "${pyvider_local_directory.test_dir.path}/config.json"
  content = jsonencode({
    app_name = "file_info_demo"
    version  = "1.0.0"
    settings = {
      debug = true
      port  = 8080
    }
  })

  depends_on = [pyvider_local_directory.test_dir]
}

# Check the files we just created
data "pyvider_file_info" "created_text" {
  path = pyvider_file_content.sample_text.filename

  depends_on = [pyvider_file_content.sample_text]
}

data "pyvider_file_info" "created_json" {
  path = pyvider_file_content.sample_json.filename

  depends_on = [pyvider_file_content.sample_json]
}

data "pyvider_file_info" "created_dir" {
  path = pyvider_local_directory.test_dir.path

  depends_on = [pyvider_local_directory.test_dir]
}

# Create a report of all file information
resource "pyvider_file_content" "file_info_report" {
  filename = "/tmp/file_info_basic_report.txt"
  content = join("\n", [
    "=== File Information Report ===",
    "",
    "=== System Files ===",
    "/etc/hosts:",
    "  Exists: ${data.pyvider_file_info.hosts_file.exists}",
    "  Type: ${data.pyvider_file_info.hosts_file.is_file ? "File" : data.pyvider_file_info.hosts_file.is_dir ? "Directory" : "Other"}",
    "  Size: ${data.pyvider_file_info.hosts_file.size} bytes",
    "  Modified: ${data.pyvider_file_info.hosts_file.modified_time}",
    "  Permissions: ${data.pyvider_file_info.hosts_file.permissions}",
    "  Owner: ${data.pyvider_file_info.hosts_file.owner}",
    "  MIME Type: ${data.pyvider_file_info.hosts_file.mime_type}",
    "",
    "/tmp directory:",
    "  Exists: ${data.pyvider_file_info.tmp_dir.exists}",
    "  Type: ${data.pyvider_file_info.tmp_dir.is_file ? "File" : data.pyvider_file_info.tmp_dir.is_dir ? "Directory" : "Other"}",
    "  Permissions: ${data.pyvider_file_info.tmp_dir.permissions}",
    "  Owner: ${data.pyvider_file_info.tmp_dir.owner}",
    "  Group: ${data.pyvider_file_info.tmp_dir.group}",
    "",
    "=== Application Config ===",
    "/etc/myapp/config.yaml:",
    "  Exists: ${data.pyvider_file_info.config_file.exists}",
    data.pyvider_file_info.config_file.exists ? "  Size: ${data.pyvider_file_info.config_file.size} bytes" : "  (File not found)",
    data.pyvider_file_info.config_file.exists ? "  Modified: ${data.pyvider_file_info.config_file.modified_time}" : "",
    "",
    "=== Current Directory ===",
    "Current working directory (.):",
    "  Exists: ${data.pyvider_file_info.current_dir.exists}",
    "  Type: ${data.pyvider_file_info.current_dir.is_dir ? "Directory" : "Not Directory"}",
    "  Permissions: ${data.pyvider_file_info.current_dir.permissions}",
    "",
    "=== Created Test Files ===",
    "Test directory (${pyvider_local_directory.test_dir.path}):",
    "  Exists: ${data.pyvider_file_info.created_dir.exists}",
    "  Type: Directory",
    "  Permissions: ${data.pyvider_file_info.created_dir.permissions}",
    "",
    "Sample text file:",
    "  Path: ${data.pyvider_file_info.created_text.path}",
    "  Exists: ${data.pyvider_file_info.created_text.exists}",
    "  Size: ${data.pyvider_file_info.created_text.size} bytes",
    "  MIME Type: ${data.pyvider_file_info.created_text.mime_type}",
    "  Modified: ${data.pyvider_file_info.created_text.modified_time}",
    "",
    "Sample JSON file:",
    "  Path: ${data.pyvider_file_info.created_json.path}",
    "  Exists: ${data.pyvider_file_info.created_json.exists}",
    "  Size: ${data.pyvider_file_info.created_json.size} bytes",
    "  MIME Type: ${data.pyvider_file_info.created_json.mime_type}",
    "  Modified: ${data.pyvider_file_info.created_json.modified_time}",
    "",
    "=== File Size Analysis ===",
    "Text file size: ${data.pyvider_file_info.created_text.size} bytes",
    "JSON file size: ${data.pyvider_file_info.created_json.size} bytes",
    "Larger file: ${data.pyvider_file_info.created_text.size > data.pyvider_file_info.created_json.size ? "text" : "json"}",
    "",
    "Report generated at: ${timestamp()}"
  ])

  depends_on = [
    data.pyvider_file_info.created_text,
    data.pyvider_file_info.created_json,
    data.pyvider_file_info.created_dir
  ]
}

# Calculate some basic statistics
locals {
  file_stats = {
    total_files_checked = 6
    existing_files = length([
      for info in [
        data.pyvider_file_info.hosts_file,
        data.pyvider_file_info.tmp_dir,
        data.pyvider_file_info.config_file,
        data.pyvider_file_info.current_dir,
        data.pyvider_file_info.created_text,
        data.pyvider_file_info.created_json
      ] : info if info.exists
    ])

    total_size_bytes = (
      data.pyvider_file_info.hosts_file.size +
      data.pyvider_file_info.created_text.size +
      data.pyvider_file_info.created_json.size
    )

    file_types = {
      regular_files = length([
        for info in [
          data.pyvider_file_info.hosts_file,
          data.pyvider_file_info.created_text,
          data.pyvider_file_info.created_json
        ] : info if info.is_file && info.exists
      ])

      directories = length([
        for info in [
          data.pyvider_file_info.tmp_dir,
          data.pyvider_file_info.current_dir,
          data.pyvider_file_info.created_dir
        ] : info if info.is_dir && info.exists
      ])
    }
  }
}

output "basic_file_info" {
  description = "Basic file information examples"
  value = {
    system_files = {
      hosts_file = {
        exists = data.pyvider_file_info.hosts_file.exists
        size = data.pyvider_file_info.hosts_file.size
        type = data.pyvider_file_info.hosts_file.is_file ? "file" : "other"
        permissions = data.pyvider_file_info.hosts_file.permissions
        mime_type = data.pyvider_file_info.hosts_file.mime_type
      }

      tmp_directory = {
        exists = data.pyvider_file_info.tmp_dir.exists
        is_directory = data.pyvider_file_info.tmp_dir.is_dir
        permissions = data.pyvider_file_info.tmp_dir.permissions
        owner = data.pyvider_file_info.tmp_dir.owner
      }
    }

    application_files = {
      config_exists = data.pyvider_file_info.config_file.exists
      current_dir_accessible = data.pyvider_file_info.current_dir.exists
    }

    created_files = {
      test_directory = {
        path = data.pyvider_file_info.created_dir.path
        exists = data.pyvider_file_info.created_dir.exists
        permissions = data.pyvider_file_info.created_dir.permissions
      }

      text_file = {
        path = data.pyvider_file_info.created_text.path
        exists = data.pyvider_file_info.created_text.exists
        size = data.pyvider_file_info.created_text.size
        mime_type = data.pyvider_file_info.created_text.mime_type
      }

      json_file = {
        path = data.pyvider_file_info.created_json.path
        exists = data.pyvider_file_info.created_json.exists
        size = data.pyvider_file_info.created_json.size
        mime_type = data.pyvider_file_info.created_json.mime_type
      }
    }

    statistics = local.file_stats

    report_file = pyvider_file_content.file_info_report.filename
  }
}

# nested_data_test_suite
# Basic nested data processor examples

# Simple nested data processing
data "pyvider_nested_data_processor" "user_profile" {
  input_data = {
    user = {
      id = 123
      name = "Alice Johnson"
      contact = {
        email = "alice@example.com"
        phone = "+1-555-0123"
        address = {
          street = "123 Main St"
          city = "New York"
          state = "NY"
          zipcode = "10001"
        }
      }
      preferences = {
        theme = "dark"
        language = "en"
        notifications = {
          email = true
          sms = false
          push = true
        }
      }
    }
  }

  # Process specific nested fields
  processors = [
    {
      name = "extract_contact_info"
      path = "user.contact"
      operation = "extract"
    },
    {
      name = "format_address"
      path = "user.contact.address"
      operation = "format"
      format_template = "{street}, {city}, {state} {zipcode}"
    },
    {
      name = "notification_summary"
      path = "user.preferences.notifications"
      operation = "summarize"
    }
  ]
}

# Complex nested data transformation
data "pyvider_nested_data_processor" "api_response" {
  input_data = {
    status = "success"
    timestamp = "2024-01-15T10:30:00Z"
    data = {
      users = [
        {
          id = 1
          name = "Alice"
          department = {
            name = "Engineering"
            budget = 500000
            manager = {
              name = "Sarah Wilson"
              email = "sarah@example.com"
            }
          }
          projects = [
            {
              name = "Project Alpha"
              status = "active"
              deadline = "2024-06-01"
              budget = 150000
            },
            {
              name = "Project Beta"
              status = "planning"
              deadline = "2024-08-15"
              budget = 200000
            }
          ]
        },
        {
          id = 2
          name = "Bob"
          department = {
            name = "Marketing"
            budget = 300000
            manager = {
              name = "Mike Chen"
              email = "mike@example.com"
            }
          }
          projects = [
            {
              name = "Campaign X"
              status = "active"
              deadline = "2024-04-30"
              budget = 75000
            }
          ]
        }
      ]
      metadata = {
        total_users = 2
        total_departments = 2
        last_updated = "2024-01-15T09:45:00Z"
      }
    }
  }

  processors = [
    {
      name = "extract_departments"
      path = "data.users[*].department.name"
      operation = "collect"
    },
    {
      name = "calculate_total_budget"
      path = "data.users[*].department.budget"
      operation = "sum"
    },
    {
      name = "extract_managers"
      path = "data.users[*].department.manager"
      operation = "collect"
    },
    {
      name = "active_projects"
      path = "data.users[*].projects[*]"
      operation = "filter"
      filter_condition = "status == 'active'"
    },
    {
      name = "project_budgets"
      path = "data.users[*].projects[*].budget"
      operation = "sum"
    }
  ]
}

# Configuration validation and processing
variable "service_config" {
  type = map(any)
  default = {
    api_server = {
      host = "api.example.com"
      port = 8080
      ssl = {
        enabled = true
        certificate = {
          path = "/etc/ssl/certs/api.crt"
          key_path = "/etc/ssl/private/api.key"
          ca_bundle = "/etc/ssl/certs/ca-bundle.crt"
        }
        protocols = ["TLSv1.2", "TLSv1.3"]
      }
      database = {
        primary = {
          host = "db1.example.com"
          port = 5432
          credentials = {
            username = "api_user"
            password_ref = "vault://secrets/db/password"
          }
          pool = {
            min_connections = 5
            max_connections = 20
            idle_timeout = 300
          }
        }
        replica = {
          host = "db2.example.com"
          port = 5432
          credentials = {
            username = "readonly_user"
            password_ref = "vault://secrets/db/readonly_password"
          }
          pool = {
            min_connections = 2
            max_connections = 10
            idle_timeout = 600
          }
        }
      }
    }
  }
}

data "pyvider_nested_data_processor" "config_analysis" {
  input_data = var.service_config

  processors = [
    {
      name = "ssl_config"
      path = "api_server.ssl"
      operation = "validate"
      validation_rules = [
        "enabled == true",
        "certificate.path != null",
        "certificate.key_path != null"
      ]
    },
    {
      name = "database_endpoints"
      path = "api_server.database.*"
      operation = "collect"
      output_format = "list"
    },
    {
      name = "total_max_connections"
      path = "api_server.database.*.pool.max_connections"
      operation = "sum"
    },
    {
      name = "credential_references"
      path = "api_server.database.*.credentials.password_ref"
      operation = "collect"
    },
    {
      name = "security_summary"
      path = "api_server"
      operation = "analyze"
      analysis_type = "security"
    }
  ]
}

# Log data processing
locals {
  log_data = {
    application_logs = [
      {
        timestamp = "2024-01-15T10:30:15Z"
        level = "INFO"
        component = "auth"
        message = "User login successful"
        context = {
          user_id = 123
          ip_address = "192.168.1.100"
          user_agent = "Mozilla/5.0..."
          session_id = "sess_abc123"
        }
        metrics = {
          response_time_ms = 45
          memory_usage_mb = 128
        }
      },
      {
        timestamp = "2024-01-15T10:31:20Z"
        level = "ERROR"
        component = "database"
        message = "Connection timeout"
        context = {
          database = "primary"
          query = "SELECT * FROM users WHERE id = ?"
          timeout_ms = 5000
        }
        metrics = {
          retry_count = 3
          total_time_ms = 15000
        }
      },
      {
        timestamp = "2024-01-15T10:32:05Z"
        level = "WARN"
        component = "cache"
        message = "Cache miss rate high"
        context = {
          cache_type = "redis"
          miss_rate = 0.85
          total_requests = 1000
        }
        metrics = {
          memory_usage_mb = 512
          hit_rate = 0.15
        }
      }
    ]
  }
}

data "pyvider_nested_data_processor" "log_analysis" {
  input_data = local.log_data

  processors = [
    {
      name = "error_logs"
      path = "application_logs[*]"
      operation = "filter"
      filter_condition = "level == 'ERROR'"
    },
    {
      name = "component_distribution"
      path = "application_logs[*].component"
      operation = "group_count"
    },
    {
      name = "average_response_time"
      path = "application_logs[*].metrics.response_time_ms"
      operation = "average"
      filter_nulls = true
    },
    {
      name = "memory_usage_stats"
      path = "application_logs[*].metrics.memory_usage_mb"
      operation = "statistics"
    },
    {
      name = "user_activities"
      path = "application_logs[*].context"
      operation = "extract"
      extract_fields = ["user_id", "ip_address", "session_id"]
      filter_nulls = true
    }
  ]
}

# E-commerce order processing
locals {
  order_data = {
    orders = [
      {
        id = "order_001"
        customer = {
          id = 123
          name = "Alice Johnson"
          email = "alice@example.com"
          tier = "premium"
          address = {
            billing = {
              street = "123 Main St"
              city = "New York"
              state = "NY"
              country = "USA"
            }
            shipping = {
              street = "456 Oak Ave"
              city = "Boston"
              state = "MA"
              country = "USA"
            }
          }
        }
        items = [
          {
            product_id = "prod_001"
            name = "Premium Widget"
            quantity = 2
            unit_price = 99.99
            category = "electronics"
            taxes = {
              rate = 0.08
              amount = 15.99
            }
          },
          {
            product_id = "prod_002"
            name = "Standard Gadget"
            quantity = 1
            unit_price = 49.99
            category = "electronics"
            taxes = {
              rate = 0.08
              amount = 4.00
            }
          }
        ]
        payment = {
          method = "credit_card"
          card = {
            last_four = "1234"
            type = "visa"
            expiry = "12/26"
          }
          amount = {
            subtotal = 249.97
            tax = 19.99
            shipping = 15.00
            total = 284.96
          }
        }
        status = "confirmed"
      }
    ]
  }
}

data "pyvider_nested_data_processor" "order_analysis" {
  input_data = local.order_data

  processors = [
    {
      name = "customer_tiers"
      path = "orders[*].customer.tier"
      operation = "group_count"
    },
    {
      name = "total_revenue"
      path = "orders[*].payment.amount.total"
      operation = "sum"
    },
    {
      name = "shipping_states"
      path = "orders[*].customer.address.shipping.state"
      operation = "collect"
    },
    {
      name = "product_categories"
      path = "orders[*].items[*].category"
      operation = "group_count"
    },
    {
      name = "average_order_value"
      path = "orders[*].payment.amount.total"
      operation = "average"
    },
    {
      name = "payment_methods"
      path = "orders[*].payment.method"
      operation = "group_count"
    },
    {
      name = "tax_summary"
      path = "orders[*].payment.amount.tax"
      operation = "statistics"
    }
  ]
}

# Create output files with processed data
resource "pyvider_file_content" "user_profile_report" {
  filename = "/tmp/user_profile_analysis.json"
  content = jsonencode({
    original_data = data.pyvider_nested_data_processor.user_profile.input_data
    processed_results = data.pyvider_nested_data_processor.user_profile.processed_data
    processing_summary = data.pyvider_nested_data_processor.user_profile.processing_summary
    generated_at = timestamp()
  })
}

resource "pyvider_file_content" "api_response_report" {
  filename = "/tmp/api_response_analysis.json"
  content = jsonencode({
    departments = data.pyvider_nested_data_processor.api_response.processed_data.extract_departments
    total_budget = data.pyvider_nested_data_processor.api_response.processed_data.calculate_total_budget
    managers = data.pyvider_nested_data_processor.api_response.processed_data.extract_managers
    active_projects = data.pyvider_nested_data_processor.api_response.processed_data.active_projects
    project_budget_total = data.pyvider_nested_data_processor.api_response.processed_data.project_budgets
    processing_summary = data.pyvider_nested_data_processor.api_response.processing_summary
    generated_at = timestamp()
  })
}

resource "pyvider_file_content" "config_analysis_report" {
  filename = "/tmp/config_analysis.json"
  content = jsonencode({
    ssl_validation = data.pyvider_nested_data_processor.config_analysis.processed_data.ssl_config
    database_endpoints = data.pyvider_nested_data_processor.config_analysis.processed_data.database_endpoints
    total_connections = data.pyvider_nested_data_processor.config_analysis.processed_data.total_max_connections
    security_analysis = data.pyvider_nested_data_processor.config_analysis.processed_data.security_summary
    generated_at = timestamp()
  })
}

resource "pyvider_file_content" "log_analysis_report" {
  filename = "/tmp/log_analysis.json"
  content = jsonencode({
    errors = data.pyvider_nested_data_processor.log_analysis.processed_data.error_logs
    component_stats = data.pyvider_nested_data_processor.log_analysis.processed_data.component_distribution
    performance = {
      avg_response_time = data.pyvider_nested_data_processor.log_analysis.processed_data.average_response_time
      memory_stats = data.pyvider_nested_data_processor.log_analysis.processed_data.memory_usage_stats
    }
    user_activities = data.pyvider_nested_data_processor.log_analysis.processed_data.user_activities
    generated_at = timestamp()
  })
}

resource "pyvider_file_content" "order_analysis_report" {
  filename = "/tmp/order_analysis.json"
  content = jsonencode({
    customer_analysis = {
      tiers = data.pyvider_nested_data_processor.order_analysis.processed_data.customer_tiers
      shipping_states = data.pyvider_nested_data_processor.order_analysis.processed_data.shipping_states
    }
    financial_analysis = {
      total_revenue = data.pyvider_nested_data_processor.order_analysis.processed_data.total_revenue
      average_order_value = data.pyvider_nested_data_processor.order_analysis.processed_data.average_order_value
      tax_summary = data.pyvider_nested_data_processor.order_analysis.processed_data.tax_summary
    }
    product_analysis = {
      categories = data.pyvider_nested_data_processor.order_analysis.processed_data.product_categories
    }
    payment_analysis = {
      methods = data.pyvider_nested_data_processor.order_analysis.processed_data.payment_methods
    }
    generated_at = timestamp()
  })
}

# Output processed data summaries
output "nested_data_processing_examples" {
  value = {
    user_profile = {
      processors_run = length(data.pyvider_nested_data_processor.user_profile.processed_data)
      report_file = pyvider_file_content.user_profile_report.filename
    }

    api_response = {
      departments_found = length(data.pyvider_nested_data_processor.api_response.processed_data.extract_departments)
      total_budget = data.pyvider_nested_data_processor.api_response.processed_data.calculate_total_budget
      report_file = pyvider_file_content.api_response_report.filename
    }

    configuration = {
      validation_passed = data.pyvider_nested_data_processor.config_analysis.processed_data.ssl_config.valid
      max_connections = data.pyvider_nested_data_processor.config_analysis.processed_data.total_max_connections
      report_file = pyvider_file_content.config_analysis_report.filename
    }

    log_analysis = {
      error_count = length(data.pyvider_nested_data_processor.log_analysis.processed_data.error_logs)
      components_found = length(keys(data.pyvider_nested_data_processor.log_analysis.processed_data.component_distribution))
      report_file = pyvider_file_content.log_analysis_report.filename
    }

    order_processing = {
      total_revenue = data.pyvider_nested_data_processor.order_analysis.processed_data.total_revenue
      average_order = data.pyvider_nested_data_processor.order_analysis.processed_data.average_order_value
      report_file = pyvider_file_content.order_analysis_report.filename
    }
  }
}


# === Functions ===

# contains
# Basic collection function examples

# Length function examples
locals {
  # List length examples
  number_list = [1, 2, 3, 4, 5]
  string_list = ["apple", "banana", "cherry"]
  empty_list = []

  number_list_length = provider::pyvider::length(local.number_list)    # Returns: 5
  string_list_length = provider::pyvider::length(local.string_list)    # Returns: 3
  empty_list_length = provider::pyvider::length(local.empty_list)      # Returns: 0

  # String length examples
  short_string = "Hello"
  long_string = "The quick brown fox jumps over the lazy dog"
  empty_string = ""

  short_string_length = provider::pyvider::length(local.short_string)  # Returns: 5
  long_string_length = provider::pyvider::length(local.long_string)    # Returns: 43
  empty_string_length = provider::pyvider::length(local.empty_string)  # Returns: 0

  # Map length examples
  simple_map = {
    name = "Alice"
    age = 30
    city = "New York"
  }
  empty_map = {}

  simple_map_length = provider::pyvider::length(local.simple_map)      # Returns: 3
  empty_map_length = provider::pyvider::length(local.empty_map)        # Returns: 0
}

# Contains function examples
locals {
  # List contains examples
  fruits = ["apple", "banana", "cherry", "date"]

  has_apple = provider::pyvider::contains(local.fruits, "apple")       # Returns: true
  has_grape = provider::pyvider::contains(local.fruits, "grape")       # Returns: false

  # String contains examples
  sample_text = "The quick brown fox"

  contains_fox = provider::pyvider::contains(local.sample_text, "fox") # Returns: true
  contains_cat = provider::pyvider::contains(local.sample_text, "cat") # Returns: false
  contains_quick = provider::pyvider::contains(local.sample_text, "quick") # Returns: true

  # Map contains examples (checks for keys)
  user_data = {
    username = "alice123"
    email = "alice@example.com"
    active = true
  }

  has_username = provider::pyvider::contains(local.user_data, "username") # Returns: true
  has_password = provider::pyvider::contains(local.user_data, "password") # Returns: false
}

# Lookup function examples
locals {
  # Simple map lookup
  config_map = {
    database_host = "db.example.com"
    database_port = 5432
    debug_mode = true
  }

  db_host = provider::pyvider::lookup(local.config_map, "database_host", "localhost")     # Returns: "db.example.com"
  cache_ttl = provider::pyvider::lookup(local.config_map, "cache_ttl", 3600)             # Returns: 3600 (default)
  ssl_enabled = provider::pyvider::lookup(local.config_map, "ssl_enabled", false)        # Returns: false (default)

  # Nested map lookup
  nested_config = {
    server = {
      host = "api.example.com"
      port = 8080
    }
    database = {
      host = "db.example.com"
      port = 5432
    }
  }

  server_info = provider::pyvider::lookup(local.nested_config, "server", {})
  cache_info = provider::pyvider::lookup(local.nested_config, "cache", { enabled = false })
}

# Combined collection operations
locals {
  # User management example
  users = [
    { name = "Alice", role = "admin", active = true },
    { name = "Bob", role = "user", active = true },
    { name = "Charlie", role = "user", active = false }
  ]

  total_users = provider::pyvider::length(local.users)

  # Check if we have any admin users
  roles = [for user in local.users : user.role]
  has_admin = provider::pyvider::contains(local.roles, "admin")

  # Environment configuration with defaults
  env_defaults = {
    environment = "development"
    log_level = "info"
    max_connections = 100
    timeout_seconds = 30
  }

  # Simulated environment variables (would come from actual env vars)
  env_vars = {
    environment = "production"
    log_level = "warn"
  }

  # Build final configuration with defaults
  final_env = provider::pyvider::lookup(local.env_vars, "environment", local.env_defaults.environment)
  final_log_level = provider::pyvider::lookup(local.env_vars, "log_level", local.env_defaults.log_level)
  final_max_conn = provider::pyvider::lookup(local.env_vars, "max_connections", local.env_defaults.max_connections)
  final_timeout = provider::pyvider::lookup(local.env_vars, "timeout_seconds", local.env_defaults.timeout_seconds)
}

# Validation examples
locals {
  # Input validation using collection functions
  required_fields = ["name", "email", "password"]
  user_input = {
    name = "John Doe"
    email = "john@example.com"
    age = 25
  }

  # Check if all required fields are present
  missing_fields = [
    for field in local.required_fields :
    field if !provider::pyvider::contains(local.user_input, field)
  ]

  has_all_required = provider::pyvider::length(local.missing_fields) == 0
}

# Output results for verification
output "collection_function_examples" {
  value = {
    length_operations = {
      lists = {
        numbers = {
          data = local.number_list
          length = local.number_list_length
        }
        strings = {
          data = local.string_list
          length = local.string_list_length
        }
        empty = {
          data = local.empty_list
          length = local.empty_list_length
        }
      }

      strings = {
        short = {
          data = local.short_string
          length = local.short_string_length
        }
        long = {
          data = local.long_string
          length = local.long_string_length
        }
        empty = {
          data = local.empty_string
          length = local.empty_string_length
        }
      }

      maps = {
        simple = {
          data = local.simple_map
          length = local.simple_map_length
        }
        empty = {
          data = local.empty_map
          length = local.empty_map_length
        }
      }
    }

    contains_operations = {
      lists = {
        fruits = local.fruits
        has_apple = local.has_apple
        has_grape = local.has_grape
      }

      strings = {
        text = local.sample_text
        contains_fox = local.contains_fox
        contains_cat = local.contains_cat
        contains_quick = local.contains_quick
      }

      maps = {
        user_data = local.user_data
        has_username = local.has_username
        has_password = local.has_password
      }
    }

    lookup_operations = {
      simple_lookups = {
        db_host = local.db_host
        cache_ttl = local.cache_ttl
        ssl_enabled = local.ssl_enabled
      }

      nested_lookups = {
        server_info = local.server_info
        cache_info = local.cache_info
      }
    }

    combined_operations = {
      user_management = {
        total_users = local.total_users
        has_admin = local.has_admin
      }

      configuration = {
        environment = local.final_env
        log_level = local.final_log_level
        max_connections = local.final_max_conn
        timeout = local.final_timeout
      }

      validation = {
        required_fields = local.required_fields
        missing_fields = local.missing_fields
        has_all_required = local.has_all_required
      }
    }
  }
}

# length
# Basic collection function examples

# Length function examples
locals {
  # List length examples
  number_list = [1, 2, 3, 4, 5]
  string_list = ["apple", "banana", "cherry"]
  empty_list = []

  number_list_length = provider::pyvider::length(local.number_list)    # Returns: 5
  string_list_length = provider::pyvider::length(local.string_list)    # Returns: 3
  empty_list_length = provider::pyvider::length(local.empty_list)      # Returns: 0

  # String length examples
  short_string = "Hello"
  long_string = "The quick brown fox jumps over the lazy dog"
  empty_string = ""

  short_string_length = provider::pyvider::length(local.short_string)  # Returns: 5
  long_string_length = provider::pyvider::length(local.long_string)    # Returns: 43
  empty_string_length = provider::pyvider::length(local.empty_string)  # Returns: 0

  # Map length examples
  simple_map = {
    name = "Alice"
    age = 30
    city = "New York"
  }
  empty_map = {}

  simple_map_length = provider::pyvider::length(local.simple_map)      # Returns: 3
  empty_map_length = provider::pyvider::length(local.empty_map)        # Returns: 0
}

# Contains function examples
locals {
  # List contains examples
  fruits = ["apple", "banana", "cherry", "date"]

  has_apple = provider::pyvider::contains(local.fruits, "apple")       # Returns: true
  has_grape = provider::pyvider::contains(local.fruits, "grape")       # Returns: false

  # String contains examples
  sample_text = "The quick brown fox"

  contains_fox = provider::pyvider::contains(local.sample_text, "fox") # Returns: true
  contains_cat = provider::pyvider::contains(local.sample_text, "cat") # Returns: false
  contains_quick = provider::pyvider::contains(local.sample_text, "quick") # Returns: true

  # Map contains examples (checks for keys)
  user_data = {
    username = "alice123"
    email = "alice@example.com"
    active = true
  }

  has_username = provider::pyvider::contains(local.user_data, "username") # Returns: true
  has_password = provider::pyvider::contains(local.user_data, "password") # Returns: false
}

# Lookup function examples
locals {
  # Simple map lookup
  config_map = {
    database_host = "db.example.com"
    database_port = 5432
    debug_mode = true
  }

  db_host = provider::pyvider::lookup(local.config_map, "database_host", "localhost")     # Returns: "db.example.com"
  cache_ttl = provider::pyvider::lookup(local.config_map, "cache_ttl", 3600)             # Returns: 3600 (default)
  ssl_enabled = provider::pyvider::lookup(local.config_map, "ssl_enabled", false)        # Returns: false (default)

  # Nested map lookup
  nested_config = {
    server = {
      host = "api.example.com"
      port = 8080
    }
    database = {
      host = "db.example.com"
      port = 5432
    }
  }

  server_info = provider::pyvider::lookup(local.nested_config, "server", {})
  cache_info = provider::pyvider::lookup(local.nested_config, "cache", { enabled = false })
}

# Combined collection operations
locals {
  # User management example
  users = [
    { name = "Alice", role = "admin", active = true },
    { name = "Bob", role = "user", active = true },
    { name = "Charlie", role = "user", active = false }
  ]

  total_users = provider::pyvider::length(local.users)

  # Check if we have any admin users
  roles = [for user in local.users : user.role]
  has_admin = provider::pyvider::contains(local.roles, "admin")

  # Environment configuration with defaults
  env_defaults = {
    environment = "development"
    log_level = "info"
    max_connections = 100
    timeout_seconds = 30
  }

  # Simulated environment variables (would come from actual env vars)
  env_vars = {
    environment = "production"
    log_level = "warn"
  }

  # Build final configuration with defaults
  final_env = provider::pyvider::lookup(local.env_vars, "environment", local.env_defaults.environment)
  final_log_level = provider::pyvider::lookup(local.env_vars, "log_level", local.env_defaults.log_level)
  final_max_conn = provider::pyvider::lookup(local.env_vars, "max_connections", local.env_defaults.max_connections)
  final_timeout = provider::pyvider::lookup(local.env_vars, "timeout_seconds", local.env_defaults.timeout_seconds)
}

# Validation examples
locals {
  # Input validation using collection functions
  required_fields = ["name", "email", "password"]
  user_input = {
    name = "John Doe"
    email = "john@example.com"
    age = 25
  }

  # Check if all required fields are present
  missing_fields = [
    for field in local.required_fields :
    field if !provider::pyvider::contains(local.user_input, field)
  ]

  has_all_required = provider::pyvider::length(local.missing_fields) == 0
}

# Output results for verification
output "collection_function_examples" {
  value = {
    length_operations = {
      lists = {
        numbers = {
          data = local.number_list
          length = local.number_list_length
        }
        strings = {
          data = local.string_list
          length = local.string_list_length
        }
        empty = {
          data = local.empty_list
          length = local.empty_list_length
        }
      }

      strings = {
        short = {
          data = local.short_string
          length = local.short_string_length
        }
        long = {
          data = local.long_string
          length = local.long_string_length
        }
        empty = {
          data = local.empty_string
          length = local.empty_string_length
        }
      }

      maps = {
        simple = {
          data = local.simple_map
          length = local.simple_map_length
        }
        empty = {
          data = local.empty_map
          length = local.empty_map_length
        }
      }
    }

    contains_operations = {
      lists = {
        fruits = local.fruits
        has_apple = local.has_apple
        has_grape = local.has_grape
      }

      strings = {
        text = local.sample_text
        contains_fox = local.contains_fox
        contains_cat = local.contains_cat
        contains_quick = local.contains_quick
      }

      maps = {
        user_data = local.user_data
        has_username = local.has_username
        has_password = local.has_password
      }
    }

    lookup_operations = {
      simple_lookups = {
        db_host = local.db_host
        cache_ttl = local.cache_ttl
        ssl_enabled = local.ssl_enabled
      }

      nested_lookups = {
        server_info = local.server_info
        cache_info = local.cache_info
      }
    }

    combined_operations = {
      user_management = {
        total_users = local.total_users
        has_admin = local.has_admin
      }

      configuration = {
        environment = local.final_env
        log_level = local.final_log_level
        max_connections = local.final_max_conn
        timeout = local.final_timeout
      }

      validation = {
        required_fields = local.required_fields
        missing_fields = local.missing_fields
        has_all_required = local.has_all_required
      }
    }
  }
}

# lookup
# Basic collection function examples

# Length function examples
locals {
  # List length examples
  number_list = [1, 2, 3, 4, 5]
  string_list = ["apple", "banana", "cherry"]
  empty_list = []

  number_list_length = provider::pyvider::length(local.number_list)    # Returns: 5
  string_list_length = provider::pyvider::length(local.string_list)    # Returns: 3
  empty_list_length = provider::pyvider::length(local.empty_list)      # Returns: 0

  # String length examples
  short_string = "Hello"
  long_string = "The quick brown fox jumps over the lazy dog"
  empty_string = ""

  short_string_length = provider::pyvider::length(local.short_string)  # Returns: 5
  long_string_length = provider::pyvider::length(local.long_string)    # Returns: 43
  empty_string_length = provider::pyvider::length(local.empty_string)  # Returns: 0

  # Map length examples
  simple_map = {
    name = "Alice"
    age = 30
    city = "New York"
  }
  empty_map = {}

  simple_map_length = provider::pyvider::length(local.simple_map)      # Returns: 3
  empty_map_length = provider::pyvider::length(local.empty_map)        # Returns: 0
}

# Contains function examples
locals {
  # List contains examples
  fruits = ["apple", "banana", "cherry", "date"]

  has_apple = provider::pyvider::contains(local.fruits, "apple")       # Returns: true
  has_grape = provider::pyvider::contains(local.fruits, "grape")       # Returns: false

  # String contains examples
  sample_text = "The quick brown fox"

  contains_fox = provider::pyvider::contains(local.sample_text, "fox") # Returns: true
  contains_cat = provider::pyvider::contains(local.sample_text, "cat") # Returns: false
  contains_quick = provider::pyvider::contains(local.sample_text, "quick") # Returns: true

  # Map contains examples (checks for keys)
  user_data = {
    username = "alice123"
    email = "alice@example.com"
    active = true
  }

  has_username = provider::pyvider::contains(local.user_data, "username") # Returns: true
  has_password = provider::pyvider::contains(local.user_data, "password") # Returns: false
}

# Lookup function examples
locals {
  # Simple map lookup
  config_map = {
    database_host = "db.example.com"
    database_port = 5432
    debug_mode = true
  }

  db_host = provider::pyvider::lookup(local.config_map, "database_host", "localhost")     # Returns: "db.example.com"
  cache_ttl = provider::pyvider::lookup(local.config_map, "cache_ttl", 3600)             # Returns: 3600 (default)
  ssl_enabled = provider::pyvider::lookup(local.config_map, "ssl_enabled", false)        # Returns: false (default)

  # Nested map lookup
  nested_config = {
    server = {
      host = "api.example.com"
      port = 8080
    }
    database = {
      host = "db.example.com"
      port = 5432
    }
  }

  server_info = provider::pyvider::lookup(local.nested_config, "server", {})
  cache_info = provider::pyvider::lookup(local.nested_config, "cache", { enabled = false })
}

# Combined collection operations
locals {
  # User management example
  users = [
    { name = "Alice", role = "admin", active = true },
    { name = "Bob", role = "user", active = true },
    { name = "Charlie", role = "user", active = false }
  ]

  total_users = provider::pyvider::length(local.users)

  # Check if we have any admin users
  roles = [for user in local.users : user.role]
  has_admin = provider::pyvider::contains(local.roles, "admin")

  # Environment configuration with defaults
  env_defaults = {
    environment = "development"
    log_level = "info"
    max_connections = 100
    timeout_seconds = 30
  }

  # Simulated environment variables (would come from actual env vars)
  env_vars = {
    environment = "production"
    log_level = "warn"
  }

  # Build final configuration with defaults
  final_env = provider::pyvider::lookup(local.env_vars, "environment", local.env_defaults.environment)
  final_log_level = provider::pyvider::lookup(local.env_vars, "log_level", local.env_defaults.log_level)
  final_max_conn = provider::pyvider::lookup(local.env_vars, "max_connections", local.env_defaults.max_connections)
  final_timeout = provider::pyvider::lookup(local.env_vars, "timeout_seconds", local.env_defaults.timeout_seconds)
}

# Validation examples
locals {
  # Input validation using collection functions
  required_fields = ["name", "email", "password"]
  user_input = {
    name = "John Doe"
    email = "john@example.com"
    age = 25
  }

  # Check if all required fields are present
  missing_fields = [
    for field in local.required_fields :
    field if !provider::pyvider::contains(local.user_input, field)
  ]

  has_all_required = provider::pyvider::length(local.missing_fields) == 0
}

# Output results for verification
output "collection_function_examples" {
  value = {
    length_operations = {
      lists = {
        numbers = {
          data = local.number_list
          length = local.number_list_length
        }
        strings = {
          data = local.string_list
          length = local.string_list_length
        }
        empty = {
          data = local.empty_list
          length = local.empty_list_length
        }
      }

      strings = {
        short = {
          data = local.short_string
          length = local.short_string_length
        }
        long = {
          data = local.long_string
          length = local.long_string_length
        }
        empty = {
          data = local.empty_string
          length = local.empty_string_length
        }
      }

      maps = {
        simple = {
          data = local.simple_map
          length = local.simple_map_length
        }
        empty = {
          data = local.empty_map
          length = local.empty_map_length
        }
      }
    }

    contains_operations = {
      lists = {
        fruits = local.fruits
        has_apple = local.has_apple
        has_grape = local.has_grape
      }

      strings = {
        text = local.sample_text
        contains_fox = local.contains_fox
        contains_cat = local.contains_cat
        contains_quick = local.contains_quick
      }

      maps = {
        user_data = local.user_data
        has_username = local.has_username
        has_password = local.has_password
      }
    }

    lookup_operations = {
      simple_lookups = {
        db_host = local.db_host
        cache_ttl = local.cache_ttl
        ssl_enabled = local.ssl_enabled
      }

      nested_lookups = {
        server_info = local.server_info
        cache_info = local.cache_info
      }
    }

    combined_operations = {
      user_management = {
        total_users = local.total_users
        has_admin = local.has_admin
      }

      configuration = {
        environment = local.final_env
        log_level = local.final_log_level
        max_connections = local.final_max_conn
        timeout = local.final_timeout
      }

      validation = {
        required_fields = local.required_fields
        missing_fields = local.missing_fields
        has_all_required = local.has_all_required
      }
    }
  }
}

# lower
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# format_size
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# to_camel_case
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# upper
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# format
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# to_kebab_case
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# join
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# truncate
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# pluralize
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# split
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# replace
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# to_snake_case
# Case conversion function examples

# Basic case conversion examples
locals {
  original_texts = [
    "user_profile_settings",
    "APIEndpointHandler",
    "database-connection-pool",
    "My Application Title",
    "SYSTEM_CONFIG_VALUE"
  ]

  # Convert to snake_case
  snake_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_snake_case(text)
  ]
  # Results: ["user_profile_settings", "api_endpoint_handler", "database_connection_pool", "my_application_title", "system_config_value"]

  # Convert to camelCase
  camel_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text)
  ]
  # Results: ["userProfileSettings", "apiEndpointHandler", "databaseConnectionPool", "myApplicationTitle", "systemConfigValue"]

  # Convert to PascalCase
  pascal_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_camel_case(text, true)
  ]
  # Results: ["UserProfileSettings", "ApiEndpointHandler", "DatabaseConnectionPool", "MyApplicationTitle", "SystemConfigValue"]

  # Convert to kebab-case
  kebab_case_results = [
    for text in local.original_texts :
    provider::pyvider::to_kebab_case(text)
  ]
  # Results: ["user-profile-settings", "api-endpoint-handler", "database-connection-pool", "my-application-title", "system-config-value"]
}

# Database to API field mapping
variable "database_fields" {
  type = list(string)
  default = [
    "user_id",
    "first_name",
    "last_name",
    "email_address",
    "phone_number",
    "created_at",
    "updated_at",
    "is_active",
    "last_login_time"
  ]
}

locals {
  # Create API field mappings
  api_field_mapping = {
    for field in var.database_fields :
    field => provider::pyvider::to_camel_case(field)
  }

  # Generate JavaScript object
  js_object_fields = [
    for db_field, api_field in local.api_field_mapping :
    "  ${api_field}: data.${db_field}"
  ]

  js_mapping_code = "const apiResponse = {\n${join(",\n", local.js_object_fields)}\n};"
}

# URL slug generation
variable "page_titles" {
  type = list(string)
  default = [
    "Getting Started with Terraform",
    "Advanced Provider Development Guide",
    "Best Practices & Common Patterns",
    "Troubleshooting Configuration Issues",
    "API Reference Documentation"
  ]
}

locals {
  # Generate URL-friendly slugs
  url_slugs = {
    for title in var.page_titles :
    title => provider::pyvider::to_kebab_case(title)
  }

  # Create navigation links
  navigation_links = [
    for title, slug in local.url_slugs :
    {
      title = title
      slug = slug
      url = "/docs/${slug}"
    }
  ]
}

# CSS class generation
variable "ui_components" {
  type = list(object({
    name = string
    type = string
  }))
  default = [
    { name = "userProfileCard", type = "component" },
    { name = "navigationMenubar", type = "layout" },
    { name = "searchInputField", type = "form" },
    { name = "dataTableContainer", type = "container" },
    { name = "modalDialogWindow", type = "overlay" }
  ]
}

locals {
  # Generate CSS classes
  css_classes = {
    for component in var.ui_components :
    component.name => {
      class_name = provider::pyvider::to_kebab_case(component.name)
      full_class = "${provider::pyvider::to_kebab_case(component.type)}-${provider::pyvider::to_kebab_case(component.name)}"
      type = component.type
    }
  }
}

# Configuration key normalization
variable "app_settings" {
  type = map(any)
  default = {
    "Database Host" = "localhost"
    "API Base URL" = "https://api.example.com"
    "Cache Timeout (seconds)" = 300
    "Debug Mode Enabled" = false
    "Max Connection Pool Size" = 20
  }
}

locals {
  # Normalize to different naming conventions
  snake_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_snake_case(display_name) => value
  }

  camel_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_camel_case(display_name) => value
  }

  kebab_case_config = {
    for display_name, value in var.app_settings :
    provider::pyvider::to_kebab_case(display_name) => value
  }
}

# File naming patterns
variable "document_info" {
  type = list(object({
    title = string
    category = string
    version = string
  }))
  default = [
    {
      title = "User Manual"
      category = "Documentation"
      version = "2.1"
    },
    {
      title = "API Reference Guide"
      category = "Technical Documentation"
      version = "1.0"
    },
    {
      title = "Installation Instructions"
      category = "Setup Guide"
      version = "3.2"
    }
  ]
}

locals {
  # Generate various filename patterns
  document_files = [
    for doc in var.document_info : {
      # Snake case filename
      snake_file = "${provider::pyvider::to_snake_case(doc.title)}_v${replace(doc.version, ".", "_")}.md"

      # Kebab case filename
      kebab_file = "${provider::pyvider::to_kebab_case(doc.title)}-v${replace(doc.version, ".", "-")}.html"

      # Category-based organization
      category_path = "${provider::pyvider::to_snake_case(doc.category)}/${provider::pyvider::to_kebab_case(doc.title)}"

      original = doc
    }
  ]
}

# Environment variable generation
variable "service_config" {
  type = map(string)
  default = {
    "Database Connection String" = "postgresql://localhost:5432/mydb"
    "Redis Cache URL" = "redis://localhost:6379"
    "API Service Port" = "8080"
    "Log Level Setting" = "INFO"
    "JWT Secret Key" = "your-secret-key"
  }
}

locals {
  # Convert to environment variable format (UPPER_SNAKE_CASE)
  env_variables = {
    for config_name, value in var.service_config :
    provider::pyvider::upper(provider::pyvider::to_snake_case(config_name)) => value
  }

  # Generate .env file content
  env_file_lines = [
    for env_name, value in local.env_variables :
    "${env_name}=${value}"
  ]
}

# Create output files
resource "pyvider_file_content" "case_conversion_examples" {
  filename = "/tmp/case_conversion_examples.txt"
  content = join("\n", [
    "=== Case Conversion Examples ===",
    "",
    "Original texts:",
    join("\n", [for i, text in local.original_texts : "  ${i + 1}. ${text}"]),
    "",
    "Snake case results:",
    join("\n", [for i, result in local.snake_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Camel case results:",
    join("\n", [for i, result in local.camel_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Pascal case results:",
    join("\n", [for i, result in local.pascal_case_results : "  ${i + 1}. ${result}"]),
    "",
    "Kebab case results:",
    join("\n", [for i, result in local.kebab_case_results : "  ${i + 1}. ${result}"])
  ])
}

resource "pyvider_file_content" "javascript_mapping" {
  filename = "/tmp/api_field_mapping.js"
  content = join("\n", [
    "// Database to API field mapping",
    "// Generated from Terraform configuration",
    "",
    local.js_mapping_code,
    "",
    "// Field mapping reference:",
    join("\n", [
      for db_field, api_field in local.api_field_mapping :
      "// ${db_field} -> ${api_field}"
    ])
  ])
}

resource "pyvider_file_content" "css_classes" {
  filename = "/tmp/component_styles.css"
  content = join("\n", concat(
    ["/* Component CSS Classes */", "/* Generated from UI component definitions */", ""],
    flatten([
      for component_name, info in local.css_classes : [
        "/* ${component_name} (${info.type}) */",
        ".${info.class_name} {",
        "  /* Component styles for ${component_name} */",
        "}",
        "",
        ".${info.full_class} {",
        "  /* Specific ${info.type} styles for ${component_name} */",
        "}",
        ""
      ]
    ])
  ))
}

resource "pyvider_file_content" "navigation_config" {
  filename = "/tmp/navigation.json"
  content = jsonencode({
    title = "Documentation Navigation"
    links = local.navigation_links
    url_mapping = local.url_slugs
  })
}

resource "pyvider_file_content" "config_files" {
  filename = "/tmp/multi_format_config.json"
  content = jsonencode({
    snake_case = local.snake_case_config
    camelCase = local.camel_case_config
    "kebab-case" = local.kebab_case_config
  })
}

resource "pyvider_file_content" "environment_variables" {
  filename = "/tmp/service.env"
  content = join("\n", concat(
    ["# Service Environment Variables", "# Generated from configuration"],
    local.env_file_lines
  ))
}

# Output conversion results
output "case_conversion_results" {
  value = {
    conversion_examples = {
      original = local.original_texts
      snake_case = local.snake_case_results
      camel_case = local.camel_case_results
      pascal_case = local.pascal_case_results
      kebab_case = local.kebab_case_results
    }

    api_mapping = {
      total_fields = length(var.database_fields)
      field_mapping = local.api_field_mapping
      js_file = pyvider_file_content.javascript_mapping.filename
    }

    web_assets = {
      navigation_links = length(local.navigation_links)
      css_classes = length(local.css_classes)
      navigation_file = pyvider_file_content.navigation_config.filename
      css_file = pyvider_file_content.css_classes.filename
    }

    configuration = {
      formats_generated = 3
      config_file = pyvider_file_content.config_files.filename
      env_file = pyvider_file_content.environment_variables.filename
      env_variables = length(local.env_variables)
    }

    file_patterns = {
      documents_processed = length(local.document_files)
      pattern_examples = [for doc in local.document_files : {
        snake_file = doc.snake_file
        kebab_file = doc.kebab_file
        category_path = doc.category_path
      }]
    }
  }
}

# tostring
# Basic type conversion function examples

# String conversion from various types
locals {
  # Number to string conversions
  integer_value = 42
  float_value = 3.14159
  negative_value = -100

  int_to_string = provider::pyvider::tostring(local.integer_value)     # Returns: "42"
  float_to_string = provider::pyvider::tostring(local.float_value)     # Returns: "3.14159"
  negative_to_string = provider::pyvider::tostring(local.negative_value) # Returns: "-100"

  # Boolean to string conversions
  true_value = true
  false_value = false

  true_to_string = provider::pyvider::tostring(local.true_value)       # Returns: "true"
  false_to_string = provider::pyvider::tostring(local.false_value)     # Returns: "false"

  # List to string conversions
  simple_list = [1, 2, 3]
  string_list = ["apple", "banana", "cherry"]
  mixed_list = [1, "two", true]

  simple_list_string = provider::pyvider::tostring(local.simple_list)  # Returns: "[1, 2, 3]"
  string_list_string = provider::pyvider::tostring(local.string_list)  # Returns: '["apple", "banana", "cherry"]'
  mixed_list_string = provider::pyvider::tostring(local.mixed_list)    # Returns: '[1, "two", true]'

  # Map to string conversions
  simple_map = {
    name = "Alice"
    age = 30
  }
  nested_map = {
    user = {
      name = "Bob"
      details = {
        age = 25
        active = true
      }
    }
  }

  simple_map_string = provider::pyvider::tostring(local.simple_map)    # Returns: '{"age": 30, "name": "Alice"}'
  nested_map_string = provider::pyvider::tostring(local.nested_map)    # Returns: nested JSON structure
}

# Practical use cases for string conversion
variable "server_config" {
  type = object({
    host     = string
    port     = number
    ssl      = bool
    timeouts = list(number)
    metadata = map(string)
  })
  default = {
    host     = "api.example.com"
    port     = 8080
    ssl      = true
    timeouts = [30, 60, 120]
    metadata = {
      environment = "production"
      version     = "1.2.3"
    }
  }
}

locals {
  # Convert configuration values to strings for logging/display
  config_strings = {
    host_info = "Server: ${var.server_config.host}:${provider::pyvider::tostring(var.server_config.port)}"
    ssl_status = "SSL Enabled: ${provider::pyvider::tostring(var.server_config.ssl)}"
    timeout_list = "Timeouts: ${provider::pyvider::tostring(var.server_config.timeouts)}"
    metadata_json = "Metadata: ${provider::pyvider::tostring(var.server_config.metadata)}"
  }

  # Create a formatted configuration summary
  config_summary = join("\n", [
    "=== Server Configuration ===",
    local.config_strings.host_info,
    local.config_strings.ssl_status,
    local.config_strings.timeout_list,
    local.config_strings.metadata_json
  ])
}

# Environment variable preparation
variable "app_settings" {
  type = object({
    debug_mode      = bool
    max_connections = number
    allowed_hosts   = list(string)
    database_config = map(any)
  })
  default = {
    debug_mode      = false
    max_connections = 100
    allowed_hosts   = ["localhost", "api.example.com"]
    database_config = {
      host     = "db.example.com"
      port     = 5432
      ssl_mode = "require"
    }
  }
}

locals {
  # Convert various types to strings for environment variables
  env_vars = {
    DEBUG_MODE      = provider::pyvider::tostring(var.app_settings.debug_mode)
    MAX_CONNECTIONS = provider::pyvider::tostring(var.app_settings.max_connections)
    ALLOWED_HOSTS   = provider::pyvider::tostring(var.app_settings.allowed_hosts)
    DATABASE_CONFIG = provider::pyvider::tostring(var.app_settings.database_config)
  }

  # Create .env file content
  env_file_content = join("\n", [
    for key, value in local.env_vars :
    "${key}=${value}"
  ])
}

# API response formatting
variable "user_data" {
  type = list(object({
    id       = number
    username = string
    active   = bool
    roles    = list(string)
    profile  = map(any)
  }))
  default = [
    {
      id       = 1
      username = "alice"
      active   = true
      roles    = ["user", "admin"]
      profile = {
        email     = "alice@example.com"
        last_login = "2024-01-15T10:30:00Z"
      }
    },
    {
      id       = 2
      username = "bob"
      active   = false
      roles    = ["user"]
      profile = {
        email = "bob@example.com"
      }
    }
  ]
}

locals {
  # Convert user data to JSON strings for API responses
  user_json_strings = [
    for user in var.user_data : {
      id_string       = provider::pyvider::tostring(user.id)
      username        = user.username  # Already a string
      active_string   = provider::pyvider::tostring(user.active)
      roles_string    = provider::pyvider::tostring(user.roles)
      profile_string  = provider::pyvider::tostring(user.profile)
      full_json       = provider::pyvider::tostring(user)
    }
  ]

  # Create a user summary report
  user_summary = join("\n", concat(
    ["=== User Data Summary ===", ""],
    flatten([
      for idx, user in var.user_data : [
        "User ${provider::pyvider::tostring(user.id)}:",
        "  Username: ${user.username}",
        "  Active: ${provider::pyvider::tostring(user.active)}",
        "  Roles: ${provider::pyvider::tostring(user.roles)}",
        "  Profile: ${provider::pyvider::tostring(user.profile)}",
        ""
      ]
    ])
  ))
}

# Logging and debugging
variable "system_metrics" {
  type = object({
    cpu_usage    = number
    memory_usage = number
    disk_usage   = number
    uptime       = number
    alerts       = list(string)
    status       = map(bool)
  })
  default = {
    cpu_usage    = 75.5
    memory_usage = 82.3
    disk_usage   = 45.7
    uptime       = 86400
    alerts       = ["high_memory", "disk_cleanup_needed"]
    status = {
      healthy     = true
      maintenance = false
      backup_running = true
    }
  }
}

locals {
  # Convert metrics to strings for logging
  metric_strings = {
    cpu    = "CPU: ${provider::pyvider::tostring(var.system_metrics.cpu_usage)}%"
    memory = "Memory: ${provider::pyvider::tostring(var.system_metrics.memory_usage)}%"
    disk   = "Disk: ${provider::pyvider::tostring(var.system_metrics.disk_usage)}%"
    uptime = "Uptime: ${provider::pyvider::tostring(var.system_metrics.uptime)} seconds"
    alerts = "Alerts: ${provider::pyvider::tostring(var.system_metrics.alerts)}"
    status = "Status: ${provider::pyvider::tostring(var.system_metrics.status)}"
  }

  # Create formatted log entry
  log_entry = join(" | ", [
    "METRICS",
    local.metric_strings.cpu,
    local.metric_strings.memory,
    local.metric_strings.disk,
    local.metric_strings.uptime,
    "Alerts: ${length(var.system_metrics.alerts)}"
  ])
}

# Create output files with converted strings
resource "pyvider_file_content" "config_summary" {
  filename = "/tmp/server_config_summary.txt"
  content  = local.config_summary
}

resource "pyvider_file_content" "environment_vars" {
  filename = "/tmp/application.env"
  content  = local.env_file_content
}

resource "pyvider_file_content" "user_report" {
  filename = "/tmp/user_data_report.txt"
  content  = local.user_summary
}

resource "pyvider_file_content" "system_log" {
  filename = "/tmp/system_metrics.log"
  content = join("\n", [
    "=== System Metrics Log ===",
    "",
    "Timestamp: ${timestamp()}",
    local.log_entry,
    "",
    "Detailed Status:",
    local.metric_strings.status,
    "",
    "Active Alerts:",
    local.metric_strings.alerts
  ])
}

# Output conversion examples
output "type_conversion_examples" {
  value = {
    basic_conversions = {
      numbers = {
        integer = {
          original = local.integer_value
          converted = local.int_to_string
        }
        float = {
          original = local.float_value
          converted = local.float_to_string
        }
        negative = {
          original = local.negative_value
          converted = local.negative_to_string
        }
      }

      booleans = {
        true_value = {
          original = local.true_value
          converted = local.true_to_string
        }
        false_value = {
          original = local.false_value
          converted = local.false_to_string
        }
      }

      collections = {
        simple_list = {
          original = local.simple_list
          converted = local.simple_list_string
        }
        string_list = {
          original = local.string_list
          converted = local.string_list_string
        }
        simple_map = {
          original = local.simple_map
          converted = local.simple_map_string
        }
      }
    }

    practical_usage = {
      configuration = {
        summary_file = pyvider_file_content.config_summary.filename
        env_file = pyvider_file_content.environment_vars.filename
      }

      user_management = {
        report_file = pyvider_file_content.user_report.filename
        total_users = length(var.user_data)
      }

      system_monitoring = {
        log_file = pyvider_file_content.system_log.filename
        log_entry = local.log_entry
      }
    }

    conversion_stats = {
      total_conversions = 15  # Approximate count of conversions performed
      file_outputs = 4        # Number of files created with converted data
    }
  }
}

# lens_jq
# Basic lens_jq function examples

# Simple data extraction
locals {
  # Sample JSON data for demonstration
  user_data = {
    id = 123
    name = "Alice Johnson"
    email = "alice@example.com"
    profile = {
      age = 30
      city = "New York"
      preferences = {
        theme = "dark"
        language = "en"
        notifications = true
      }
    }
    roles = ["user", "moderator"]
    metadata = {
      created_at = "2024-01-15T10:30:00Z"
      last_login = "2024-01-20T14:22:15Z"
      login_count = 42
    }
  }

  # Basic field extraction
  user_name = provider::pyvider::lens_jq(local.user_data, ".name")
  user_email = provider::pyvider::lens_jq(local.user_data, ".email")
  user_id = provider::pyvider::lens_jq(local.user_data, ".id")

  # Nested field extraction
  user_age = provider::pyvider::lens_jq(local.user_data, ".profile.age")
  user_city = provider::pyvider::lens_jq(local.user_data, ".profile.city")
  user_theme = provider::pyvider::lens_jq(local.user_data, ".profile.preferences.theme")

  # Array access
  first_role = provider::pyvider::lens_jq(local.user_data, ".roles[0]")
  second_role = provider::pyvider::lens_jq(local.user_data, ".roles[1]")
  all_roles = provider::pyvider::lens_jq(local.user_data, ".roles")
}

# Complex data transformation
locals {
  # Sample API response data
  api_response = {
    status = "success"
    data = {
      users = [
        {
          id = 1
          name = "Alice"
          email = "alice@example.com"
          active = true
          department = "Engineering"
          salary = 85000
        },
        {
          id = 2
          name = "Bob"
          email = "bob@example.com"
          active = true
          department = "Marketing"
          salary = 65000
        },
        {
          id = 3
          name = "Charlie"
          email = "charlie@example.com"
          active = false
          department = "Engineering"
          salary = 90000
        }
      ]
      metadata = {
        total_count = 3
        page = 1
        per_page = 10
      }
    }
  }

  # Extract specific information
  all_users = provider::pyvider::lens_jq(local.api_response, ".data.users")
  active_users = provider::pyvider::lens_jq(local.api_response, ".data.users | map(select(.active == true))")
  engineering_users = provider::pyvider::lens_jq(local.api_response, ".data.users | map(select(.department == \"Engineering\"))")

  # Extract names only
  all_names = provider::pyvider::lens_jq(local.api_response, ".data.users | map(.name)")
  active_names = provider::pyvider::lens_jq(local.api_response, ".data.users | map(select(.active == true)) | map(.name)")

  # Calculate aggregates
  total_salary = provider::pyvider::lens_jq(local.api_response, ".data.users | map(.salary) | add")
  average_salary = provider::pyvider::lens_jq(local.api_response, ".data.users | map(.salary) | add / length")
  max_salary = provider::pyvider::lens_jq(local.api_response, ".data.users | map(.salary) | max")
  min_salary = provider::pyvider::lens_jq(local.api_response, ".data.users | map(.salary) | min")
}

# Configuration processing
variable "app_config" {
  type = map(any)
  default = {
    database = {
      connections = [
        {
          name = "primary"
          host = "db1.example.com"
          port = 5432
          ssl = true
          pool_size = 20
        },
        {
          name = "replica"
          host = "db2.example.com"
          port = 5432
          ssl = true
          pool_size = 10
        },
        {
          name = "analytics"
          host = "analytics-db.example.com"
          port = 5432
          ssl = false
          pool_size = 5
        }
      ]
    }
    services = {
      api = {
        host = "api.example.com"
        port = 8080
        instances = 3
      }
      worker = {
        host = "worker.example.com"
        port = 8081
        instances = 2
      }
    }
  }
}

locals {
  # Extract database connection information
  primary_db = provider::pyvider::lens_jq(var.app_config, ".database.connections | map(select(.name == \"primary\")) | .[0]")
  ssl_enabled_dbs = provider::pyvider::lens_jq(var.app_config, ".database.connections | map(select(.ssl == true))")
  total_pool_size = provider::pyvider::lens_jq(var.app_config, ".database.connections | map(.pool_size) | add")

  # Extract service information
  api_instances = provider::pyvider::lens_jq(var.app_config, ".services.api.instances")
  worker_instances = provider::pyvider::lens_jq(var.app_config, ".services.worker.instances")
  total_instances = provider::pyvider::lens_jq(var.app_config, ".services | [.api.instances, .worker.instances] | add")

  # Create connection strings
  db_hosts = provider::pyvider::lens_jq(var.app_config, ".database.connections | map(.host)")
  service_endpoints = provider::pyvider::lens_jq(var.app_config, ".services | to_entries | map(\"\\(.key)://\\(.value.host):\\(.value.port)\")")
}

# Log analysis
locals {
  # Sample log data
  log_entries = [
    {
      timestamp = "2024-01-15T10:30:15Z"
      level = "INFO"
      message = "Application started"
      user_id = null
      request_id = "req-001"
    },
    {
      timestamp = "2024-01-15T10:30:16Z"
      level = "DEBUG"
      message = "Database connection established"
      user_id = null
      request_id = "req-001"
    },
    {
      timestamp = "2024-01-15T10:31:20Z"
      level = "INFO"
      message = "User login successful"
      user_id = 123
      request_id = "req-002"
    },
    {
      timestamp = "2024-01-15T10:32:10Z"
      level = "WARN"
      message = "Rate limit exceeded"
      user_id = 456
      request_id = "req-003"
    },
    {
      timestamp = "2024-01-15T10:33:05Z"
      level = "ERROR"
      message = "Database query failed"
      user_id = 123
      request_id = "req-004"
    }
  ]

  # Analyze log data
  error_logs = provider::pyvider::lens_jq(local.log_entries, "map(select(.level == \"ERROR\"))")
  warning_logs = provider::pyvider::lens_jq(local.log_entries, "map(select(.level == \"WARN\"))")
  user_related_logs = provider::pyvider::lens_jq(local.log_entries, "map(select(.user_id != null))")

  # Extract specific information
  error_messages = provider::pyvider::lens_jq(local.log_entries, "map(select(.level == \"ERROR\")) | map(.message)")
  unique_users = provider::pyvider::lens_jq(local.log_entries, "map(.user_id) | map(select(. != null)) | unique")
  log_levels = provider::pyvider::lens_jq(local.log_entries, "map(.level) | unique")

  # Count statistics
  error_count = provider::pyvider::lens_jq(local.log_entries, "map(select(.level == \"ERROR\")) | length")
  warning_count = provider::pyvider::lens_jq(local.log_entries, "map(select(.level == \"WARN\")) | length")
  total_logs = provider::pyvider::lens_jq(local.log_entries, "length")
}

# Create analysis reports
resource "pyvider_file_content" "user_analysis" {
  filename = "/tmp/user_analysis.json"
  content = jsonencode({
    user_profile = {
      name = local.user_name
      email = local.user_email
      age = local.user_age
      city = local.user_city
      theme = local.user_theme
      roles = local.all_roles
    }
    extracted_at = timestamp()
  })
}

resource "pyvider_file_content" "team_analysis" {
  filename = "/tmp/team_analysis.json"
  content = jsonencode({
    summary = {
      total_users = length(local.all_users)
      active_users = length(local.active_users)
      engineering_team = length(local.engineering_users)
    }
    salary_analysis = {
      total = local.total_salary
      average = local.average_salary
      max = local.max_salary
      min = local.min_salary
    }
    names = {
      all = local.all_names
      active_only = local.active_names
    }
    generated_at = timestamp()
  })
}

resource "pyvider_file_content" "config_analysis" {
  filename = "/tmp/config_analysis.json"
  content = jsonencode({
    database = {
      primary_connection = local.primary_db
      ssl_enabled_count = length(local.ssl_enabled_dbs)
      total_pool_size = local.total_pool_size
      hosts = local.db_hosts
    }
    services = {
      api_instances = local.api_instances
      worker_instances = local.worker_instances
      total_instances = local.total_instances
      endpoints = local.service_endpoints
    }
    analyzed_at = timestamp()
  })
}

resource "pyvider_file_content" "log_analysis" {
  filename = "/tmp/log_analysis.json"
  content = jsonencode({
    statistics = {
      total_logs = local.total_logs
      error_count = local.error_count
      warning_count = local.warning_count
    }
    levels_found = local.log_levels
    unique_users = local.unique_users
    error_messages = local.error_messages
    sample_logs = {
      errors = local.error_logs
      warnings = local.warning_logs
      user_related = local.user_related_logs
    }
    analyzed_at = timestamp()
  })
}

# Output lens operations results
output "lens_jq_examples" {
  value = {
    user_extraction = {
      name = local.user_name
      email = local.user_email
      age = local.user_age
      roles = local.all_roles
      analysis_file = pyvider_file_content.user_analysis.filename
    }

    team_analysis = {
      total_users = length(local.all_users)
      active_count = length(local.active_users)
      engineering_count = length(local.engineering_users)
      salary_stats = {
        total = local.total_salary
        average = local.average_salary
        range = "${local.min_salary} - ${local.max_salary}"
      }
      analysis_file = pyvider_file_content.team_analysis.filename
    }

    configuration = {
      database_pools = local.total_pool_size
      service_instances = local.total_instances
      ssl_connections = length(local.ssl_enabled_dbs)
      analysis_file = pyvider_file_content.config_analysis.filename
    }

    log_analysis = {
      total_entries = local.total_logs
      errors = local.error_count
      warnings = local.warning_count
      unique_users = length(local.unique_users)
      analysis_file = pyvider_file_content.log_analysis.filename
    }
  }
}

# divide
# Resource calculation examples using numeric functions

# Calculate total CPU cores across instances
variable "instance_types" {
  type = list(object({
    name  = string
    cores = number
    count = number
  }))
  default = [
    { name = "web", cores = 2, count = 3 },
    { name = "api", cores = 4, count = 2 },
    { name = "db", cores = 8, count = 1 }
  ]
}

locals {
  # Calculate cores per instance type
  web_total_cores = provider::pyvider::multiply(
    var.instance_types[0].cores,
    var.instance_types[0].count
  )  # 2 * 3 = 6

  api_total_cores = provider::pyvider::multiply(
    var.instance_types[1].cores,
    var.instance_types[1].count
  )  # 4 * 2 = 8

  db_total_cores = provider::pyvider::multiply(
    var.instance_types[2].cores,
    var.instance_types[2].count
  )  # 8 * 1 = 8

  # Sum all cores
  all_core_counts = [
    local.web_total_cores,
    local.api_total_cores,
    local.db_total_cores
  ]
  total_cores = provider::pyvider::sum(local.all_core_counts)  # 6 + 8 + 8 = 22
}

# Memory allocation calculations
variable "base_memory_gb" {
  type    = number
  default = 4
}

variable "memory_multiplier" {
  type    = number
  default = 1.5
}

locals {
  # Calculate memory per instance type
  web_memory_per_instance = provider::pyvider::multiply(
    var.base_memory_gb,
    var.memory_multiplier
  )  # 4 * 1.5 = 6

  # Round to nearest GB
  web_memory_rounded = provider::pyvider::round(local.web_memory_per_instance, 0)  # 6

  # Calculate total memory for web tier
  web_total_memory = provider::pyvider::multiply(
    local.web_memory_rounded,
    var.instance_types[0].count
  )  # 6 * 3 = 18
}

# Storage calculations
variable "base_storage_gb" {
  type    = number
  default = 100
}

variable "additional_storage_gb" {
  type    = number
  default = 50
}

locals {
  # Calculate storage per instance
  storage_per_instance = provider::pyvider::add(
    var.base_storage_gb,
    var.additional_storage_gb
  )  # 100 + 50 = 150

  # Calculate total storage needed
  total_instances = provider::pyvider::sum([
    var.instance_types[0].count,
    var.instance_types[1].count,
    var.instance_types[2].count
  ])  # 3 + 2 + 1 = 6

  total_storage = provider::pyvider::multiply(
    local.storage_per_instance,
    local.total_instances
  )  # 150 * 6 = 900
}

# Cost calculations
variable "cost_per_core_hour" {
  type    = number
  default = 0.05
}

variable "hours_per_month" {
  type    = number
  default = 730
}

locals {
  # Calculate monthly compute cost
  cost_per_core_month = provider::pyvider::multiply(
    var.cost_per_core_hour,
    var.hours_per_month
  )  # 0.05 * 730 = 36.5

  total_monthly_compute_cost = provider::pyvider::multiply(
    local.cost_per_core_month,
    local.total_cores
  )  # 36.5 * 22 = 803

  # Round to nearest dollar
  monthly_cost_rounded = provider::pyvider::round(local.total_monthly_compute_cost, 0)  # 803
}

# Create resource allocation summary
resource "pyvider_file_content" "resource_summary" {
  filename = "/tmp/resource_allocation.txt"
  content = join("\n", [
    "=== Resource Allocation Summary ===",
    "",
    "CPU Allocation:",
    "  Web tier: ${local.web_total_cores} cores (${var.instance_types[0].count} × ${var.instance_types[0].cores})",
    "  API tier: ${local.api_total_cores} cores (${var.instance_types[1].count} × ${var.instance_types[1].cores})",
    "  DB tier: ${local.db_total_cores} cores (${var.instance_types[2].count} × ${var.instance_types[2].cores})",
    "  Total: ${local.total_cores} cores",
    "",
    "Memory Allocation:",
    "  Web tier total: ${local.web_total_memory} GB",
    "  Per instance: ${local.web_memory_rounded} GB",
    "",
    "Storage Allocation:",
    "  Per instance: ${local.storage_per_instance} GB",
    "  Total instances: ${local.total_instances}",
    "  Total storage: ${local.total_storage} GB",
    "",
    "Cost Estimation:",
    "  Cost per core/month: $${local.cost_per_core_month}",
    "  Monthly compute cost: $${local.monthly_cost_rounded}",
    "",
    "Generated: ${timestamp()}"
  ])
}

# Output the calculations
output "resource_calculations" {
  value = {
    cpu = {
      web_cores = local.web_total_cores
      api_cores = local.api_total_cores
      db_cores = local.db_total_cores
      total_cores = local.total_cores
    }
    memory = {
      web_total_gb = local.web_total_memory
      per_instance_gb = local.web_memory_rounded
    }
    storage = {
      per_instance_gb = local.storage_per_instance
      total_instances = local.total_instances
      total_storage_gb = local.total_storage
    }
    cost = {
      monthly_compute = local.monthly_cost_rounded
      per_core_month = local.cost_per_core_month
    }
  }
}

# subtract
# Resource calculation examples using numeric functions

# Calculate total CPU cores across instances
variable "instance_types" {
  type = list(object({
    name  = string
    cores = number
    count = number
  }))
  default = [
    { name = "web", cores = 2, count = 3 },
    { name = "api", cores = 4, count = 2 },
    { name = "db", cores = 8, count = 1 }
  ]
}

locals {
  # Calculate cores per instance type
  web_total_cores = provider::pyvider::multiply(
    var.instance_types[0].cores,
    var.instance_types[0].count
  )  # 2 * 3 = 6

  api_total_cores = provider::pyvider::multiply(
    var.instance_types[1].cores,
    var.instance_types[1].count
  )  # 4 * 2 = 8

  db_total_cores = provider::pyvider::multiply(
    var.instance_types[2].cores,
    var.instance_types[2].count
  )  # 8 * 1 = 8

  # Sum all cores
  all_core_counts = [
    local.web_total_cores,
    local.api_total_cores,
    local.db_total_cores
  ]
  total_cores = provider::pyvider::sum(local.all_core_counts)  # 6 + 8 + 8 = 22
}

# Memory allocation calculations
variable "base_memory_gb" {
  type    = number
  default = 4
}

variable "memory_multiplier" {
  type    = number
  default = 1.5
}

locals {
  # Calculate memory per instance type
  web_memory_per_instance = provider::pyvider::multiply(
    var.base_memory_gb,
    var.memory_multiplier
  )  # 4 * 1.5 = 6

  # Round to nearest GB
  web_memory_rounded = provider::pyvider::round(local.web_memory_per_instance, 0)  # 6

  # Calculate total memory for web tier
  web_total_memory = provider::pyvider::multiply(
    local.web_memory_rounded,
    var.instance_types[0].count
  )  # 6 * 3 = 18
}

# Storage calculations
variable "base_storage_gb" {
  type    = number
  default = 100
}

variable "additional_storage_gb" {
  type    = number
  default = 50
}

locals {
  # Calculate storage per instance
  storage_per_instance = provider::pyvider::add(
    var.base_storage_gb,
    var.additional_storage_gb
  )  # 100 + 50 = 150

  # Calculate total storage needed
  total_instances = provider::pyvider::sum([
    var.instance_types[0].count,
    var.instance_types[1].count,
    var.instance_types[2].count
  ])  # 3 + 2 + 1 = 6

  total_storage = provider::pyvider::multiply(
    local.storage_per_instance,
    local.total_instances
  )  # 150 * 6 = 900
}

# Cost calculations
variable "cost_per_core_hour" {
  type    = number
  default = 0.05
}

variable "hours_per_month" {
  type    = number
  default = 730
}

locals {
  # Calculate monthly compute cost
  cost_per_core_month = provider::pyvider::multiply(
    var.cost_per_core_hour,
    var.hours_per_month
  )  # 0.05 * 730 = 36.5

  total_monthly_compute_cost = provider::pyvider::multiply(
    local.cost_per_core_month,
    local.total_cores
  )  # 36.5 * 22 = 803

  # Round to nearest dollar
  monthly_cost_rounded = provider::pyvider::round(local.total_monthly_compute_cost, 0)  # 803
}

# Create resource allocation summary
resource "pyvider_file_content" "resource_summary" {
  filename = "/tmp/resource_allocation.txt"
  content = join("\n", [
    "=== Resource Allocation Summary ===",
    "",
    "CPU Allocation:",
    "  Web tier: ${local.web_total_cores} cores (${var.instance_types[0].count} × ${var.instance_types[0].cores})",
    "  API tier: ${local.api_total_cores} cores (${var.instance_types[1].count} × ${var.instance_types[1].cores})",
    "  DB tier: ${local.db_total_cores} cores (${var.instance_types[2].count} × ${var.instance_types[2].cores})",
    "  Total: ${local.total_cores} cores",
    "",
    "Memory Allocation:",
    "  Web tier total: ${local.web_total_memory} GB",
    "  Per instance: ${local.web_memory_rounded} GB",
    "",
    "Storage Allocation:",
    "  Per instance: ${local.storage_per_instance} GB",
    "  Total instances: ${local.total_instances}",
    "  Total storage: ${local.total_storage} GB",
    "",
    "Cost Estimation:",
    "  Cost per core/month: $${local.cost_per_core_month}",
    "  Monthly compute cost: $${local.monthly_cost_rounded}",
    "",
    "Generated: ${timestamp()}"
  ])
}

# Output the calculations
output "resource_calculations" {
  value = {
    cpu = {
      web_cores = local.web_total_cores
      api_cores = local.api_total_cores
      db_cores = local.db_total_cores
      total_cores = local.total_cores
    }
    memory = {
      web_total_gb = local.web_total_memory
      per_instance_gb = local.web_memory_rounded
    }
    storage = {
      per_instance_gb = local.storage_per_instance
      total_instances = local.total_instances
      total_storage_gb = local.total_storage
    }
    cost = {
      monthly_compute = local.monthly_cost_rounded
      per_core_month = local.cost_per_core_month
    }
  }
}

# max
# Resource calculation examples using numeric functions

# Calculate total CPU cores across instances
variable "instance_types" {
  type = list(object({
    name  = string
    cores = number
    count = number
  }))
  default = [
    { name = "web", cores = 2, count = 3 },
    { name = "api", cores = 4, count = 2 },
    { name = "db", cores = 8, count = 1 }
  ]
}

locals {
  # Calculate cores per instance type
  web_total_cores = provider::pyvider::multiply(
    var.instance_types[0].cores,
    var.instance_types[0].count
  )  # 2 * 3 = 6

  api_total_cores = provider::pyvider::multiply(
    var.instance_types[1].cores,
    var.instance_types[1].count
  )  # 4 * 2 = 8

  db_total_cores = provider::pyvider::multiply(
    var.instance_types[2].cores,
    var.instance_types[2].count
  )  # 8 * 1 = 8

  # Sum all cores
  all_core_counts = [
    local.web_total_cores,
    local.api_total_cores,
    local.db_total_cores
  ]
  total_cores = provider::pyvider::sum(local.all_core_counts)  # 6 + 8 + 8 = 22
}

# Memory allocation calculations
variable "base_memory_gb" {
  type    = number
  default = 4
}

variable "memory_multiplier" {
  type    = number
  default = 1.5
}

locals {
  # Calculate memory per instance type
  web_memory_per_instance = provider::pyvider::multiply(
    var.base_memory_gb,
    var.memory_multiplier
  )  # 4 * 1.5 = 6

  # Round to nearest GB
  web_memory_rounded = provider::pyvider::round(local.web_memory_per_instance, 0)  # 6

  # Calculate total memory for web tier
  web_total_memory = provider::pyvider::multiply(
    local.web_memory_rounded,
    var.instance_types[0].count
  )  # 6 * 3 = 18
}

# Storage calculations
variable "base_storage_gb" {
  type    = number
  default = 100
}

variable "additional_storage_gb" {
  type    = number
  default = 50
}

locals {
  # Calculate storage per instance
  storage_per_instance = provider::pyvider::add(
    var.base_storage_gb,
    var.additional_storage_gb
  )  # 100 + 50 = 150

  # Calculate total storage needed
  total_instances = provider::pyvider::sum([
    var.instance_types[0].count,
    var.instance_types[1].count,
    var.instance_types[2].count
  ])  # 3 + 2 + 1 = 6

  total_storage = provider::pyvider::multiply(
    local.storage_per_instance,
    local.total_instances
  )  # 150 * 6 = 900
}

# Cost calculations
variable "cost_per_core_hour" {
  type    = number
  default = 0.05
}

variable "hours_per_month" {
  type    = number
  default = 730
}

locals {
  # Calculate monthly compute cost
  cost_per_core_month = provider::pyvider::multiply(
    var.cost_per_core_hour,
    var.hours_per_month
  )  # 0.05 * 730 = 36.5

  total_monthly_compute_cost = provider::pyvider::multiply(
    local.cost_per_core_month,
    local.total_cores
  )  # 36.5 * 22 = 803

  # Round to nearest dollar
  monthly_cost_rounded = provider::pyvider::round(local.total_monthly_compute_cost, 0)  # 803
}

# Create resource allocation summary
resource "pyvider_file_content" "resource_summary" {
  filename = "/tmp/resource_allocation.txt"
  content = join("\n", [
    "=== Resource Allocation Summary ===",
    "",
    "CPU Allocation:",
    "  Web tier: ${local.web_total_cores} cores (${var.instance_types[0].count} × ${var.instance_types[0].cores})",
    "  API tier: ${local.api_total_cores} cores (${var.instance_types[1].count} × ${var.instance_types[1].cores})",
    "  DB tier: ${local.db_total_cores} cores (${var.instance_types[2].count} × ${var.instance_types[2].cores})",
    "  Total: ${local.total_cores} cores",
    "",
    "Memory Allocation:",
    "  Web tier total: ${local.web_total_memory} GB",
    "  Per instance: ${local.web_memory_rounded} GB",
    "",
    "Storage Allocation:",
    "  Per instance: ${local.storage_per_instance} GB",
    "  Total instances: ${local.total_instances}",
    "  Total storage: ${local.total_storage} GB",
    "",
    "Cost Estimation:",
    "  Cost per core/month: $${local.cost_per_core_month}",
    "  Monthly compute cost: $${local.monthly_cost_rounded}",
    "",
    "Generated: ${timestamp()}"
  ])
}

# Output the calculations
output "resource_calculations" {
  value = {
    cpu = {
      web_cores = local.web_total_cores
      api_cores = local.api_total_cores
      db_cores = local.db_total_cores
      total_cores = local.total_cores
    }
    memory = {
      web_total_gb = local.web_total_memory
      per_instance_gb = local.web_memory_rounded
    }
    storage = {
      per_instance_gb = local.storage_per_instance
      total_instances = local.total_instances
      total_storage_gb = local.total_storage
    }
    cost = {
      monthly_compute = local.monthly_cost_rounded
      per_core_month = local.cost_per_core_month
    }
  }
}

# sum
# Resource calculation examples using numeric functions

# Calculate total CPU cores across instances
variable "instance_types" {
  type = list(object({
    name  = string
    cores = number
    count = number
  }))
  default = [
    { name = "web", cores = 2, count = 3 },
    { name = "api", cores = 4, count = 2 },
    { name = "db", cores = 8, count = 1 }
  ]
}

locals {
  # Calculate cores per instance type
  web_total_cores = provider::pyvider::multiply(
    var.instance_types[0].cores,
    var.instance_types[0].count
  )  # 2 * 3 = 6

  api_total_cores = provider::pyvider::multiply(
    var.instance_types[1].cores,
    var.instance_types[1].count
  )  # 4 * 2 = 8

  db_total_cores = provider::pyvider::multiply(
    var.instance_types[2].cores,
    var.instance_types[2].count
  )  # 8 * 1 = 8

  # Sum all cores
  all_core_counts = [
    local.web_total_cores,
    local.api_total_cores,
    local.db_total_cores
  ]
  total_cores = provider::pyvider::sum(local.all_core_counts)  # 6 + 8 + 8 = 22
}

# Memory allocation calculations
variable "base_memory_gb" {
  type    = number
  default = 4
}

variable "memory_multiplier" {
  type    = number
  default = 1.5
}

locals {
  # Calculate memory per instance type
  web_memory_per_instance = provider::pyvider::multiply(
    var.base_memory_gb,
    var.memory_multiplier
  )  # 4 * 1.5 = 6

  # Round to nearest GB
  web_memory_rounded = provider::pyvider::round(local.web_memory_per_instance, 0)  # 6

  # Calculate total memory for web tier
  web_total_memory = provider::pyvider::multiply(
    local.web_memory_rounded,
    var.instance_types[0].count
  )  # 6 * 3 = 18
}

# Storage calculations
variable "base_storage_gb" {
  type    = number
  default = 100
}

variable "additional_storage_gb" {
  type    = number
  default = 50
}

locals {
  # Calculate storage per instance
  storage_per_instance = provider::pyvider::add(
    var.base_storage_gb,
    var.additional_storage_gb
  )  # 100 + 50 = 150

  # Calculate total storage needed
  total_instances = provider::pyvider::sum([
    var.instance_types[0].count,
    var.instance_types[1].count,
    var.instance_types[2].count
  ])  # 3 + 2 + 1 = 6

  total_storage = provider::pyvider::multiply(
    local.storage_per_instance,
    local.total_instances
  )  # 150 * 6 = 900
}

# Cost calculations
variable "cost_per_core_hour" {
  type    = number
  default = 0.05
}

variable "hours_per_month" {
  type    = number
  default = 730
}

locals {
  # Calculate monthly compute cost
  cost_per_core_month = provider::pyvider::multiply(
    var.cost_per_core_hour,
    var.hours_per_month
  )  # 0.05 * 730 = 36.5

  total_monthly_compute_cost = provider::pyvider::multiply(
    local.cost_per_core_month,
    local.total_cores
  )  # 36.5 * 22 = 803

  # Round to nearest dollar
  monthly_cost_rounded = provider::pyvider::round(local.total_monthly_compute_cost, 0)  # 803
}

# Create resource allocation summary
resource "pyvider_file_content" "resource_summary" {
  filename = "/tmp/resource_allocation.txt"
  content = join("\n", [
    "=== Resource Allocation Summary ===",
    "",
    "CPU Allocation:",
    "  Web tier: ${local.web_total_cores} cores (${var.instance_types[0].count} × ${var.instance_types[0].cores})",
    "  API tier: ${local.api_total_cores} cores (${var.instance_types[1].count} × ${var.instance_types[1].cores})",
    "  DB tier: ${local.db_total_cores} cores (${var.instance_types[2].count} × ${var.instance_types[2].cores})",
    "  Total: ${local.total_cores} cores",
    "",
    "Memory Allocation:",
    "  Web tier total: ${local.web_total_memory} GB",
    "  Per instance: ${local.web_memory_rounded} GB",
    "",
    "Storage Allocation:",
    "  Per instance: ${local.storage_per_instance} GB",
    "  Total instances: ${local.total_instances}",
    "  Total storage: ${local.total_storage} GB",
    "",
    "Cost Estimation:",
    "  Cost per core/month: $${local.cost_per_core_month}",
    "  Monthly compute cost: $${local.monthly_cost_rounded}",
    "",
    "Generated: ${timestamp()}"
  ])
}

# Output the calculations
output "resource_calculations" {
  value = {
    cpu = {
      web_cores = local.web_total_cores
      api_cores = local.api_total_cores
      db_cores = local.db_total_cores
      total_cores = local.total_cores
    }
    memory = {
      web_total_gb = local.web_total_memory
      per_instance_gb = local.web_memory_rounded
    }
    storage = {
      per_instance_gb = local.storage_per_instance
      total_instances = local.total_instances
      total_storage_gb = local.total_storage
    }
    cost = {
      monthly_compute = local.monthly_cost_rounded
      per_core_month = local.cost_per_core_month
    }
  }
}

# round
# Resource calculation examples using numeric functions

# Calculate total CPU cores across instances
variable "instance_types" {
  type = list(object({
    name  = string
    cores = number
    count = number
  }))
  default = [
    { name = "web", cores = 2, count = 3 },
    { name = "api", cores = 4, count = 2 },
    { name = "db", cores = 8, count = 1 }
  ]
}

locals {
  # Calculate cores per instance type
  web_total_cores = provider::pyvider::multiply(
    var.instance_types[0].cores,
    var.instance_types[0].count
  )  # 2 * 3 = 6

  api_total_cores = provider::pyvider::multiply(
    var.instance_types[1].cores,
    var.instance_types[1].count
  )  # 4 * 2 = 8

  db_total_cores = provider::pyvider::multiply(
    var.instance_types[2].cores,
    var.instance_types[2].count
  )  # 8 * 1 = 8

  # Sum all cores
  all_core_counts = [
    local.web_total_cores,
    local.api_total_cores,
    local.db_total_cores
  ]
  total_cores = provider::pyvider::sum(local.all_core_counts)  # 6 + 8 + 8 = 22
}

# Memory allocation calculations
variable "base_memory_gb" {
  type    = number
  default = 4
}

variable "memory_multiplier" {
  type    = number
  default = 1.5
}

locals {
  # Calculate memory per instance type
  web_memory_per_instance = provider::pyvider::multiply(
    var.base_memory_gb,
    var.memory_multiplier
  )  # 4 * 1.5 = 6

  # Round to nearest GB
  web_memory_rounded = provider::pyvider::round(local.web_memory_per_instance, 0)  # 6

  # Calculate total memory for web tier
  web_total_memory = provider::pyvider::multiply(
    local.web_memory_rounded,
    var.instance_types[0].count
  )  # 6 * 3 = 18
}

# Storage calculations
variable "base_storage_gb" {
  type    = number
  default = 100
}

variable "additional_storage_gb" {
  type    = number
  default = 50
}

locals {
  # Calculate storage per instance
  storage_per_instance = provider::pyvider::add(
    var.base_storage_gb,
    var.additional_storage_gb
  )  # 100 + 50 = 150

  # Calculate total storage needed
  total_instances = provider::pyvider::sum([
    var.instance_types[0].count,
    var.instance_types[1].count,
    var.instance_types[2].count
  ])  # 3 + 2 + 1 = 6

  total_storage = provider::pyvider::multiply(
    local.storage_per_instance,
    local.total_instances
  )  # 150 * 6 = 900
}

# Cost calculations
variable "cost_per_core_hour" {
  type    = number
  default = 0.05
}

variable "hours_per_month" {
  type    = number
  default = 730
}

locals {
  # Calculate monthly compute cost
  cost_per_core_month = provider::pyvider::multiply(
    var.cost_per_core_hour,
    var.hours_per_month
  )  # 0.05 * 730 = 36.5

  total_monthly_compute_cost = provider::pyvider::multiply(
    local.cost_per_core_month,
    local.total_cores
  )  # 36.5 * 22 = 803

  # Round to nearest dollar
  monthly_cost_rounded = provider::pyvider::round(local.total_monthly_compute_cost, 0)  # 803
}

# Create resource allocation summary
resource "pyvider_file_content" "resource_summary" {
  filename = "/tmp/resource_allocation.txt"
  content = join("\n", [
    "=== Resource Allocation Summary ===",
    "",
    "CPU Allocation:",
    "  Web tier: ${local.web_total_cores} cores (${var.instance_types[0].count} × ${var.instance_types[0].cores})",
    "  API tier: ${local.api_total_cores} cores (${var.instance_types[1].count} × ${var.instance_types[1].cores})",
    "  DB tier: ${local.db_total_cores} cores (${var.instance_types[2].count} × ${var.instance_types[2].cores})",
    "  Total: ${local.total_cores} cores",
    "",
    "Memory Allocation:",
    "  Web tier total: ${local.web_total_memory} GB",
    "  Per instance: ${local.web_memory_rounded} GB",
    "",
    "Storage Allocation:",
    "  Per instance: ${local.storage_per_instance} GB",
    "  Total instances: ${local.total_instances}",
    "  Total storage: ${local.total_storage} GB",
    "",
    "Cost Estimation:",
    "  Cost per core/month: $${local.cost_per_core_month}",
    "  Monthly compute cost: $${local.monthly_cost_rounded}",
    "",
    "Generated: ${timestamp()}"
  ])
}

# Output the calculations
output "resource_calculations" {
  value = {
    cpu = {
      web_cores = local.web_total_cores
      api_cores = local.api_total_cores
      db_cores = local.db_total_cores
      total_cores = local.total_cores
    }
    memory = {
      web_total_gb = local.web_total_memory
      per_instance_gb = local.web_memory_rounded
    }
    storage = {
      per_instance_gb = local.storage_per_instance
      total_instances = local.total_instances
      total_storage_gb = local.total_storage
    }
    cost = {
      monthly_compute = local.monthly_cost_rounded
      per_core_month = local.cost_per_core_month
    }
  }
}

# multiply
# Resource calculation examples using numeric functions

# Calculate total CPU cores across instances
variable "instance_types" {
  type = list(object({
    name  = string
    cores = number
    count = number
  }))
  default = [
    { name = "web", cores = 2, count = 3 },
    { name = "api", cores = 4, count = 2 },
    { name = "db", cores = 8, count = 1 }
  ]
}

locals {
  # Calculate cores per instance type
  web_total_cores = provider::pyvider::multiply(
    var.instance_types[0].cores,
    var.instance_types[0].count
  )  # 2 * 3 = 6

  api_total_cores = provider::pyvider::multiply(
    var.instance_types[1].cores,
    var.instance_types[1].count
  )  # 4 * 2 = 8

  db_total_cores = provider::pyvider::multiply(
    var.instance_types[2].cores,
    var.instance_types[2].count
  )  # 8 * 1 = 8

  # Sum all cores
  all_core_counts = [
    local.web_total_cores,
    local.api_total_cores,
    local.db_total_cores
  ]
  total_cores = provider::pyvider::sum(local.all_core_counts)  # 6 + 8 + 8 = 22
}

# Memory allocation calculations
variable "base_memory_gb" {
  type    = number
  default = 4
}

variable "memory_multiplier" {
  type    = number
  default = 1.5
}

locals {
  # Calculate memory per instance type
  web_memory_per_instance = provider::pyvider::multiply(
    var.base_memory_gb,
    var.memory_multiplier
  )  # 4 * 1.5 = 6

  # Round to nearest GB
  web_memory_rounded = provider::pyvider::round(local.web_memory_per_instance, 0)  # 6

  # Calculate total memory for web tier
  web_total_memory = provider::pyvider::multiply(
    local.web_memory_rounded,
    var.instance_types[0].count
  )  # 6 * 3 = 18
}

# Storage calculations
variable "base_storage_gb" {
  type    = number
  default = 100
}

variable "additional_storage_gb" {
  type    = number
  default = 50
}

locals {
  # Calculate storage per instance
  storage_per_instance = provider::pyvider::add(
    var.base_storage_gb,
    var.additional_storage_gb
  )  # 100 + 50 = 150

  # Calculate total storage needed
  total_instances = provider::pyvider::sum([
    var.instance_types[0].count,
    var.instance_types[1].count,
    var.instance_types[2].count
  ])  # 3 + 2 + 1 = 6

  total_storage = provider::pyvider::multiply(
    local.storage_per_instance,
    local.total_instances
  )  # 150 * 6 = 900
}

# Cost calculations
variable "cost_per_core_hour" {
  type    = number
  default = 0.05
}

variable "hours_per_month" {
  type    = number
  default = 730
}

locals {
  # Calculate monthly compute cost
  cost_per_core_month = provider::pyvider::multiply(
    var.cost_per_core_hour,
    var.hours_per_month
  )  # 0.05 * 730 = 36.5

  total_monthly_compute_cost = provider::pyvider::multiply(
    local.cost_per_core_month,
    local.total_cores
  )  # 36.5 * 22 = 803

  # Round to nearest dollar
  monthly_cost_rounded = provider::pyvider::round(local.total_monthly_compute_cost, 0)  # 803
}

# Create resource allocation summary
resource "pyvider_file_content" "resource_summary" {
  filename = "/tmp/resource_allocation.txt"
  content = join("\n", [
    "=== Resource Allocation Summary ===",
    "",
    "CPU Allocation:",
    "  Web tier: ${local.web_total_cores} cores (${var.instance_types[0].count} × ${var.instance_types[0].cores})",
    "  API tier: ${local.api_total_cores} cores (${var.instance_types[1].count} × ${var.instance_types[1].cores})",
    "  DB tier: ${local.db_total_cores} cores (${var.instance_types[2].count} × ${var.instance_types[2].cores})",
    "  Total: ${local.total_cores} cores",
    "",
    "Memory Allocation:",
    "  Web tier total: ${local.web_total_memory} GB",
    "  Per instance: ${local.web_memory_rounded} GB",
    "",
    "Storage Allocation:",
    "  Per instance: ${local.storage_per_instance} GB",
    "  Total instances: ${local.total_instances}",
    "  Total storage: ${local.total_storage} GB",
    "",
    "Cost Estimation:",
    "  Cost per core/month: $${local.cost_per_core_month}",
    "  Monthly compute cost: $${local.monthly_cost_rounded}",
    "",
    "Generated: ${timestamp()}"
  ])
}

# Output the calculations
output "resource_calculations" {
  value = {
    cpu = {
      web_cores = local.web_total_cores
      api_cores = local.api_total_cores
      db_cores = local.db_total_cores
      total_cores = local.total_cores
    }
    memory = {
      web_total_gb = local.web_total_memory
      per_instance_gb = local.web_memory_rounded
    }
    storage = {
      per_instance_gb = local.storage_per_instance
      total_instances = local.total_instances
      total_storage_gb = local.total_storage
    }
    cost = {
      monthly_compute = local.monthly_cost_rounded
      per_core_month = local.cost_per_core_month
    }
  }
}

# min
# Resource calculation examples using numeric functions

# Calculate total CPU cores across instances
variable "instance_types" {
  type = list(object({
    name  = string
    cores = number
    count = number
  }))
  default = [
    { name = "web", cores = 2, count = 3 },
    { name = "api", cores = 4, count = 2 },
    { name = "db", cores = 8, count = 1 }
  ]
}

locals {
  # Calculate cores per instance type
  web_total_cores = provider::pyvider::multiply(
    var.instance_types[0].cores,
    var.instance_types[0].count
  )  # 2 * 3 = 6

  api_total_cores = provider::pyvider::multiply(
    var.instance_types[1].cores,
    var.instance_types[1].count
  )  # 4 * 2 = 8

  db_total_cores = provider::pyvider::multiply(
    var.instance_types[2].cores,
    var.instance_types[2].count
  )  # 8 * 1 = 8

  # Sum all cores
  all_core_counts = [
    local.web_total_cores,
    local.api_total_cores,
    local.db_total_cores
  ]
  total_cores = provider::pyvider::sum(local.all_core_counts)  # 6 + 8 + 8 = 22
}

# Memory allocation calculations
variable "base_memory_gb" {
  type    = number
  default = 4
}

variable "memory_multiplier" {
  type    = number
  default = 1.5
}

locals {
  # Calculate memory per instance type
  web_memory_per_instance = provider::pyvider::multiply(
    var.base_memory_gb,
    var.memory_multiplier
  )  # 4 * 1.5 = 6

  # Round to nearest GB
  web_memory_rounded = provider::pyvider::round(local.web_memory_per_instance, 0)  # 6

  # Calculate total memory for web tier
  web_total_memory = provider::pyvider::multiply(
    local.web_memory_rounded,
    var.instance_types[0].count
  )  # 6 * 3 = 18
}

# Storage calculations
variable "base_storage_gb" {
  type    = number
  default = 100
}

variable "additional_storage_gb" {
  type    = number
  default = 50
}

locals {
  # Calculate storage per instance
  storage_per_instance = provider::pyvider::add(
    var.base_storage_gb,
    var.additional_storage_gb
  )  # 100 + 50 = 150

  # Calculate total storage needed
  total_instances = provider::pyvider::sum([
    var.instance_types[0].count,
    var.instance_types[1].count,
    var.instance_types[2].count
  ])  # 3 + 2 + 1 = 6

  total_storage = provider::pyvider::multiply(
    local.storage_per_instance,
    local.total_instances
  )  # 150 * 6 = 900
}

# Cost calculations
variable "cost_per_core_hour" {
  type    = number
  default = 0.05
}

variable "hours_per_month" {
  type    = number
  default = 730
}

locals {
  # Calculate monthly compute cost
  cost_per_core_month = provider::pyvider::multiply(
    var.cost_per_core_hour,
    var.hours_per_month
  )  # 0.05 * 730 = 36.5

  total_monthly_compute_cost = provider::pyvider::multiply(
    local.cost_per_core_month,
    local.total_cores
  )  # 36.5 * 22 = 803

  # Round to nearest dollar
  monthly_cost_rounded = provider::pyvider::round(local.total_monthly_compute_cost, 0)  # 803
}

# Create resource allocation summary
resource "pyvider_file_content" "resource_summary" {
  filename = "/tmp/resource_allocation.txt"
  content = join("\n", [
    "=== Resource Allocation Summary ===",
    "",
    "CPU Allocation:",
    "  Web tier: ${local.web_total_cores} cores (${var.instance_types[0].count} × ${var.instance_types[0].cores})",
    "  API tier: ${local.api_total_cores} cores (${var.instance_types[1].count} × ${var.instance_types[1].cores})",
    "  DB tier: ${local.db_total_cores} cores (${var.instance_types[2].count} × ${var.instance_types[2].cores})",
    "  Total: ${local.total_cores} cores",
    "",
    "Memory Allocation:",
    "  Web tier total: ${local.web_total_memory} GB",
    "  Per instance: ${local.web_memory_rounded} GB",
    "",
    "Storage Allocation:",
    "  Per instance: ${local.storage_per_instance} GB",
    "  Total instances: ${local.total_instances}",
    "  Total storage: ${local.total_storage} GB",
    "",
    "Cost Estimation:",
    "  Cost per core/month: $${local.cost_per_core_month}",
    "  Monthly compute cost: $${local.monthly_cost_rounded}",
    "",
    "Generated: ${timestamp()}"
  ])
}

# Output the calculations
output "resource_calculations" {
  value = {
    cpu = {
      web_cores = local.web_total_cores
      api_cores = local.api_total_cores
      db_cores = local.db_total_cores
      total_cores = local.total_cores
    }
    memory = {
      web_total_gb = local.web_total_memory
      per_instance_gb = local.web_memory_rounded
    }
    storage = {
      per_instance_gb = local.storage_per_instance
      total_instances = local.total_instances
      total_storage_gb = local.total_storage
    }
    cost = {
      monthly_compute = local.monthly_cost_rounded
      per_core_month = local.cost_per_core_month
    }
  }
}

# add
# Resource calculation examples using numeric functions

# Calculate total CPU cores across instances
variable "instance_types" {
  type = list(object({
    name  = string
    cores = number
    count = number
  }))
  default = [
    { name = "web", cores = 2, count = 3 },
    { name = "api", cores = 4, count = 2 },
    { name = "db", cores = 8, count = 1 }
  ]
}

locals {
  # Calculate cores per instance type
  web_total_cores = provider::pyvider::multiply(
    var.instance_types[0].cores,
    var.instance_types[0].count
  )  # 2 * 3 = 6

  api_total_cores = provider::pyvider::multiply(
    var.instance_types[1].cores,
    var.instance_types[1].count
  )  # 4 * 2 = 8

  db_total_cores = provider::pyvider::multiply(
    var.instance_types[2].cores,
    var.instance_types[2].count
  )  # 8 * 1 = 8

  # Sum all cores
  all_core_counts = [
    local.web_total_cores,
    local.api_total_cores,
    local.db_total_cores
  ]
  total_cores = provider::pyvider::sum(local.all_core_counts)  # 6 + 8 + 8 = 22
}

# Memory allocation calculations
variable "base_memory_gb" {
  type    = number
  default = 4
}

variable "memory_multiplier" {
  type    = number
  default = 1.5
}

locals {
  # Calculate memory per instance type
  web_memory_per_instance = provider::pyvider::multiply(
    var.base_memory_gb,
    var.memory_multiplier
  )  # 4 * 1.5 = 6

  # Round to nearest GB
  web_memory_rounded = provider::pyvider::round(local.web_memory_per_instance, 0)  # 6

  # Calculate total memory for web tier
  web_total_memory = provider::pyvider::multiply(
    local.web_memory_rounded,
    var.instance_types[0].count
  )  # 6 * 3 = 18
}

# Storage calculations
variable "base_storage_gb" {
  type    = number
  default = 100
}

variable "additional_storage_gb" {
  type    = number
  default = 50
}

locals {
  # Calculate storage per instance
  storage_per_instance = provider::pyvider::add(
    var.base_storage_gb,
    var.additional_storage_gb
  )  # 100 + 50 = 150

  # Calculate total storage needed
  total_instances = provider::pyvider::sum([
    var.instance_types[0].count,
    var.instance_types[1].count,
    var.instance_types[2].count
  ])  # 3 + 2 + 1 = 6

  total_storage = provider::pyvider::multiply(
    local.storage_per_instance,
    local.total_instances
  )  # 150 * 6 = 900
}

# Cost calculations
variable "cost_per_core_hour" {
  type    = number
  default = 0.05
}

variable "hours_per_month" {
  type    = number
  default = 730
}

locals {
  # Calculate monthly compute cost
  cost_per_core_month = provider::pyvider::multiply(
    var.cost_per_core_hour,
    var.hours_per_month
  )  # 0.05 * 730 = 36.5

  total_monthly_compute_cost = provider::pyvider::multiply(
    local.cost_per_core_month,
    local.total_cores
  )  # 36.5 * 22 = 803

  # Round to nearest dollar
  monthly_cost_rounded = provider::pyvider::round(local.total_monthly_compute_cost, 0)  # 803
}

# Create resource allocation summary
resource "pyvider_file_content" "resource_summary" {
  filename = "/tmp/resource_allocation.txt"
  content = join("\n", [
    "=== Resource Allocation Summary ===",
    "",
    "CPU Allocation:",
    "  Web tier: ${local.web_total_cores} cores (${var.instance_types[0].count} × ${var.instance_types[0].cores})",
    "  API tier: ${local.api_total_cores} cores (${var.instance_types[1].count} × ${var.instance_types[1].cores})",
    "  DB tier: ${local.db_total_cores} cores (${var.instance_types[2].count} × ${var.instance_types[2].cores})",
    "  Total: ${local.total_cores} cores",
    "",
    "Memory Allocation:",
    "  Web tier total: ${local.web_total_memory} GB",
    "  Per instance: ${local.web_memory_rounded} GB",
    "",
    "Storage Allocation:",
    "  Per instance: ${local.storage_per_instance} GB",
    "  Total instances: ${local.total_instances}",
    "  Total storage: ${local.total_storage} GB",
    "",
    "Cost Estimation:",
    "  Cost per core/month: $${local.cost_per_core_month}",
    "  Monthly compute cost: $${local.monthly_cost_rounded}",
    "",
    "Generated: ${timestamp()}"
  ])
}

# Output the calculations
output "resource_calculations" {
  value = {
    cpu = {
      web_cores = local.web_total_cores
      api_cores = local.api_total_cores
      db_cores = local.db_total_cores
      total_cores = local.total_cores
    }
    memory = {
      web_total_gb = local.web_total_memory
      per_instance_gb = local.web_memory_rounded
    }
    storage = {
      per_instance_gb = local.storage_per_instance
      total_instances = local.total_instances
      total_storage_gb = local.total_storage
    }
    cost = {
      monthly_compute = local.monthly_cost_rounded
      per_core_month = local.cost_per_core_month
    }
  }
}


