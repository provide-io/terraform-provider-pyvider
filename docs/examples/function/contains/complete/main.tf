terraform {
  required_providers {
    pyvider = {
      source  = "local/providers/pyvider"
      version = ">= 0.0.5"
    }
  }
}

provider "pyvider" {
  # Provider configuration
  # Add your configuration options here
}

# Generated by Plating - Executable Example
# === Basic Example ===

# Basic collection function examples

# Length function examples
locals {
  # List length examples
  number_list = [1, 2, 3, 4, 5]
  string_list = ["apple", "banana", "cherry"]
  empty_list  = []

  number_list_length = provider::pyvider::length(local.number_list) # Returns: 5
  string_list_length = provider::pyvider::length(local.string_list) # Returns: 3
  empty_list_length  = provider::pyvider::length(local.empty_list)  # Returns: 0

  # String length examples
  short_string = "Hello"
  long_string  = "The quick brown fox jumps over the lazy dog"
  empty_string = ""

  short_string_length = provider::pyvider::length(local.short_string) # Returns: 5
  long_string_length  = provider::pyvider::length(local.long_string)  # Returns: 43
  empty_string_length = provider::pyvider::length(local.empty_string) # Returns: 0

  # Map length examples
  simple_map = {
    name = "Alice"
    age  = 30
    city = "New York"
  }
  empty_map = {}

  simple_map_length = provider::pyvider::length(local.simple_map) # Returns: 3
  empty_map_length  = provider::pyvider::length(local.empty_map)  # Returns: 0
}

# Contains function examples
locals {
  # List contains examples
  fruits = ["apple", "banana", "cherry", "date"]

  has_apple = provider::pyvider::contains(local.fruits, "apple") # Returns: true
  has_grape = provider::pyvider::contains(local.fruits, "grape") # Returns: false

  # String contains examples
  sample_text = "The quick brown fox"

  contains_fox   = provider::pyvider::contains(local.sample_text, "fox")   # Returns: true
  contains_cat   = provider::pyvider::contains(local.sample_text, "cat")   # Returns: false
  contains_quick = provider::pyvider::contains(local.sample_text, "quick") # Returns: true

  # Map contains examples (checks for keys)
  user_data = {
    username = "alice123"
    email    = "alice@example.com"
    active   = true
  }

  has_username = provider::pyvider::contains(local.user_data, "username") # Returns: true
  has_password = provider::pyvider::contains(local.user_data, "password") # Returns: false
}

# Lookup function examples
locals {
  # Simple map lookup
  config_map = {
    database_host = "db.example.com"
    database_port = 5432
    debug_mode    = true
  }

  db_host     = provider::pyvider::lookup(local.config_map, "database_host", "localhost") # Returns: "db.example.com"
  cache_ttl   = provider::pyvider::lookup(local.config_map, "cache_ttl", 3600)            # Returns: 3600 (default)
  ssl_enabled = provider::pyvider::lookup(local.config_map, "ssl_enabled", false)         # Returns: false (default)

  # Nested map lookup
  nested_config = {
    server = {
      host = "api.example.com"
      port = 8080
    }
    database = {
      host = "db.example.com"
      port = 5432
    }
  }

  server_info = provider::pyvider::lookup(local.nested_config, "server", {})
  cache_info  = provider::pyvider::lookup(local.nested_config, "cache", { enabled = false })
}

# Combined collection operations
locals {
  # User management example
  users = [
    { name = "Alice", role = "admin", active = true },
    { name = "Bob", role = "user", active = true },
    { name = "Charlie", role = "user", active = false }
  ]

  total_users = provider::pyvider::length(local.users)

  # Check if we have any admin users
  roles     = [for user in local.users : user.role]
  has_admin = provider::pyvider::contains(local.roles, "admin")

  # Environment configuration with defaults
  env_defaults = {
    environment     = "development"
    log_level       = "info"
    max_connections = 100
    timeout_seconds = 30
  }

  # Simulated environment variables (would come from actual env vars)
  env_vars = {
    environment = "production"
    log_level   = "warn"
  }

  # Build final configuration with defaults
  final_env       = provider::pyvider::lookup(local.env_vars, "environment", local.env_defaults.environment)
  final_log_level = provider::pyvider::lookup(local.env_vars, "log_level", local.env_defaults.log_level)
  final_max_conn  = provider::pyvider::lookup(local.env_vars, "max_connections", local.env_defaults.max_connections)
  final_timeout   = provider::pyvider::lookup(local.env_vars, "timeout_seconds", local.env_defaults.timeout_seconds)
}

# Validation examples
locals {
  # Input validation using collection functions
  required_fields = ["name", "email", "password"]
  user_input = {
    name  = "John Doe"
    email = "john@example.com"
    age   = 25
  }

  # Check if all required fields are present
  missing_fields = [
    for field in local.required_fields :
    field if !provider::pyvider::contains(local.user_input, field)
  ]

  has_all_required = provider::pyvider::length(local.missing_fields) == 0
}

# Output results for verification
output "collection_function_examples" {
  value = {
    length_operations = {
      lists = {
        numbers = {
          data   = local.number_list
          length = local.number_list_length
        }
        strings = {
          data   = local.string_list
          length = local.string_list_length
        }
        empty = {
          data   = local.empty_list
          length = local.empty_list_length
        }
      }

      strings = {
        short = {
          data   = local.short_string
          length = local.short_string_length
        }
        long = {
          data   = local.long_string
          length = local.long_string_length
        }
        empty = {
          data   = local.empty_string
          length = local.empty_string_length
        }
      }

      maps = {
        simple = {
          data   = local.simple_map
          length = local.simple_map_length
        }
        empty = {
          data   = local.empty_map
          length = local.empty_map_length
        }
      }
    }

    contains_operations = {
      lists = {
        fruits    = local.fruits
        has_apple = local.has_apple
        has_grape = local.has_grape
      }

      strings = {
        text           = local.sample_text
        contains_fox   = local.contains_fox
        contains_cat   = local.contains_cat
        contains_quick = local.contains_quick
      }

      maps = {
        user_data    = local.user_data
        has_username = local.has_username
        has_password = local.has_password
      }
    }

    lookup_operations = {
      simple_lookups = {
        db_host     = local.db_host
        cache_ttl   = local.cache_ttl
        ssl_enabled = local.ssl_enabled
      }

      nested_lookups = {
        server_info = local.server_info
        cache_info  = local.cache_info
      }
    }

    combined_operations = {
      user_management = {
        total_users = local.total_users
        has_admin   = local.has_admin
      }

      configuration = {
        environment     = local.final_env
        log_level       = local.final_log_level
        max_connections = local.final_max_conn
        timeout         = local.final_timeout
      }

      validation = {
        required_fields  = local.required_fields
        missing_fields   = local.missing_fields
        has_all_required = local.has_all_required
      }
    }
  }
}


# === Example Example ===

# Collection function examples

# Example 1: Working with maps and lookups
locals {
  database_configs = {
    "development" = "localhost:5432"
    "staging"     = "staging-db.example.com:5432"
    "production"  = "prod-db.example.com:5432"
  }

  environment = "staging"

  # Lookup with default value
  db_host = provider::pyvider::lookup(
    local.database_configs,
    local.environment,
    "default.example.com:5432"
  )

  # Lookup for a missing key
  test_db = provider::pyvider::lookup(
    local.database_configs,
    "testing",
    "test.example.com:5432"
  )
}

# Example 2: String and list operations
locals {
  service_names = ["web", "api", "database", "cache", "monitor"]
  log_message   = "Error connecting to database service"

  # Check if service exists
  has_database  = provider::pyvider::contains(local.service_names, "database")
  has_analytics = provider::pyvider::contains(local.service_names, "analytics")

  # Check if log contains error
  is_error_log = provider::pyvider::contains(local.log_message, "Error")

  # Get collection sizes
  service_count = provider::pyvider::length(local.service_names)
  log_length    = provider::pyvider::length(local.log_message)
}

# Example 3: Configuration management with lookups
locals {
  app_settings = {
    "max_connections" = "100"
    "timeout_seconds" = "30"
    "retry_attempts"  = "3"
    "log_level"       = "INFO"
    "cache_enabled"   = "true"
  }

  feature_flags = {
    "new_ui"        = true
    "analytics"     = false
    "dark_mode"     = true
    "beta_features" = false
  }

  # Get configuration values with defaults
  max_conn        = provider::pyvider::lookup(local.app_settings, "max_connections", "50")
  timeout         = provider::pyvider::lookup(local.app_settings, "timeout_seconds", "60")
  unknown_setting = provider::pyvider::lookup(local.app_settings, "unknown_key", "default_value")

  # Check feature flags
  ui_enabled      = provider::pyvider::lookup(local.feature_flags, "new_ui", false)
  missing_feature = provider::pyvider::lookup(local.feature_flags, "missing_feature", false)
}

# Example 4: Complex data processing
data "pyvider_env_variables" "app_vars" {
  prefix = "APP_"
}

locals {
  # Process environment variables
  env_var_names = keys(data.pyvider_env_variables.app_vars.values)
  env_var_count = provider::pyvider::length(local.env_var_names)

  # Check for specific environment variables
  has_database_url = provider::pyvider::contains(local.env_var_names, "APP_DATABASE_URL")
  has_secret_key   = provider::pyvider::contains(local.env_var_names, "APP_SECRET_KEY")

  # Get values with fallbacks
  app_name = provider::pyvider::lookup(
    data.pyvider_env_variables.app_vars.values,
    "APP_NAME",
    "DefaultApp"
  )

  app_version = provider::pyvider::lookup(
    data.pyvider_env_variables.app_vars.values,
    "APP_VERSION",
    "1.0.0"
  )
}

# Example 5: Service discovery and validation
locals {
  required_services  = ["web", "api", "database"]
  available_services = ["web", "api", "database", "cache", "monitor", "logging"]

  # Check if all required services are available
  service_checks = {
    for service in local.required_services :
    service => provider::pyvider::contains(local.available_services, service)
  }

  # Count available vs required
  required_count  = provider::pyvider::length(local.required_services)
  available_count = provider::pyvider::length(local.available_services)

  # Find missing services (this would require more complex logic in real Terraform)
  all_services_available = alltrue([for check in values(local.service_checks) : check])
}

# Example 6: Network configuration with lookups
locals {
  network_configs = {
    "vpc-prod"    = "10.0.0.0/16"
    "vpc-staging" = "10.1.0.0/16"
    "vpc-dev"     = "10.2.0.0/16"
  }

  subnet_configs = {
    "public"  = "/24"
    "private" = "/24"
    "db"      = "/28"
  }

  current_vpc = "vpc-prod"
  subnet_type = "private"

  # Get network configuration
  vpc_cidr    = provider::pyvider::lookup(local.network_configs, local.current_vpc, "172.16.0.0/16")
  subnet_mask = provider::pyvider::lookup(local.subnet_configs, local.subnet_type, "/24")

  # Configuration validation
  has_vpc_config    = provider::pyvider::contains(keys(local.network_configs), local.current_vpc)
  has_subnet_config = provider::pyvider::contains(keys(local.subnet_configs), local.subnet_type)

  total_vpcs         = provider::pyvider::length(local.network_configs)
  total_subnet_types = provider::pyvider::length(local.subnet_configs)
}

# Create a comprehensive report
resource "pyvider_file_content" "collection_examples" {
  filename = "/tmp/collection_function_examples.txt"
  content = join("\n", [
    "=== Collection Function Examples ===",
    "",
    "=== Database Configuration ===",
    "Environment: ${local.environment}",
    "Database host: ${local.db_host}",
    "Test database: ${local.test_db}",
    "",
    "=== Service Management ===",
    "Available services: ${jsonencode(local.service_names)}",
    "Service count: ${local.service_count}",
    "Has database service: ${local.has_database}",
    "Has analytics service: ${local.has_analytics}",
    "",
    "=== Log Analysis ===",
    "Log message: '${local.log_message}'",
    "Message length: ${local.log_length} characters",
    "Is error log: ${local.is_error_log}",
    "",
    "=== Application Settings ===",
    "Max connections: ${local.max_conn}",
    "Timeout: ${local.timeout} seconds",
    "Unknown setting: ${local.unknown_setting}",
    "New UI enabled: ${local.ui_enabled}",
    "",
    "=== Environment Variables ===",
    "App name: ${local.app_name}",
    "App version: ${local.app_version}",
    "Environment variable count: ${local.env_var_count}",
    "Has database URL: ${local.has_database_url}",
    "Has secret key: ${local.has_secret_key}",
    "",
    "=== Service Discovery ===",
    "Required services: ${jsonencode(local.required_services)}",
    "Available services: ${jsonencode(local.available_services)}",
    "Required count: ${local.required_count}",
    "Available count: ${local.available_count}",
    "All services available: ${local.all_services_available}",
    "",
    "=== Network Configuration ===",
    "Current VPC: ${local.current_vpc}",
    "VPC CIDR: ${local.vpc_cidr}",
    "Subnet type: ${local.subnet_type}",
    "Subnet mask: ${local.subnet_mask}",
    "Has VPC config: ${local.has_vpc_config}",
    "Total VPCs configured: ${local.total_vpcs}",
    "",
    "Generated at: ${timestamp()}"
  ])
}

output "collection_function_results" {
  description = "Results of various collection operations"
  value = {
    database_config = {
      environment = local.environment
      host        = local.db_host
      test_host   = local.test_db
    }

    service_management = {
      service_count = local.service_count
      has_database  = local.has_database
      has_analytics = local.has_analytics
    }

    log_analysis = {
      message_length = local.log_length
      is_error       = local.is_error_log
    }

    app_configuration = {
      name            = local.app_name
      version         = local.app_version
      max_connections = local.max_conn
      timeout         = local.timeout
      ui_enabled      = local.ui_enabled
    }

    environment_vars = {
      count            = local.env_var_count
      has_database_url = local.has_database_url
      has_secret_key   = local.has_secret_key
    }

    service_discovery = {
      required_services  = local.required_count
      available_services = local.available_count
      all_available      = local.all_services_available
      service_checks     = local.service_checks
    }

    network_config = {
      vpc_cidr       = local.vpc_cidr
      subnet_mask    = local.subnet_mask
      has_vpc_config = local.has_vpc_config
      total_vpcs     = local.total_vpcs
    }

    examples_file = pyvider_file_content.collection_examples.filename
  }
}


# === Data_Validation Example ===

# Data validation examples using collection functions

# User input validation
variable "user_registrations" {
  type = list(object({
    username = string
    email    = string
    age      = optional(number)
    roles    = optional(list(string), [])
  }))
  default = [
    {
      username = "alice123"
      email    = "alice@example.com"
      age      = 30
      roles    = ["user", "moderator"]
    },
    {
      username = "bob456"
      email    = "bob@example.com"
      roles    = ["user"]
    },
    {
      username = "charlie789"
      email    = "charlie@test.com"
      age      = 25
    }
  ]
}

locals {
  # Define validation rules
  required_fields     = ["username", "email"]
  valid_roles         = ["user", "admin", "moderator", "guest"]
  min_username_length = 3
  max_username_length = 20

  # Validate each user registration
  validation_results = [
    for idx, user in var.user_registrations : {
      index    = idx
      username = user.username
      email    = user.email

      # Check required fields
      has_username = provider::pyvider::contains(user, "username") && provider::pyvider::length(user.username) > 0
      has_email    = provider::pyvider::contains(user, "email") && provider::pyvider::length(user.email) > 0

      # Username validation
      username_length = provider::pyvider::length(user.username)
      username_valid_length = (
        local.username_length >= local.min_username_length &&
        local.username_length <= local.max_username_length
      )
      username_has_at_symbol = provider::pyvider::contains(user.username, "@")

      # Email validation (basic)
      email_has_at  = provider::pyvider::contains(user.email, "@")
      email_has_dot = provider::pyvider::contains(user.email, ".")

      # Role validation
      invalid_roles = [
        for role in user.roles :
        role if !provider::pyvider::contains(local.valid_roles, role)
      ]
      has_invalid_roles = provider::pyvider::length(local.invalid_roles) > 0

      # Overall validation
      is_valid = (
        local.has_username &&
        local.has_email &&
        local.username_valid_length &&
        !local.username_has_at_symbol &&
        local.email_has_at &&
        local.email_has_dot &&
        !local.has_invalid_roles
      )

      # Collect all errors
      errors = concat(
        !local.has_username ? ["Missing username"] : [],
        !local.has_email ? ["Missing email"] : [],
        !local.username_valid_length ? ["Username length must be ${local.min_username_length}-${local.max_username_length} characters"] : [],
        local.username_has_at_symbol ? ["Username cannot contain @ symbol"] : [],
        !local.email_has_at ? ["Email must contain @ symbol"] : [],
        !local.email_has_dot ? ["Email must contain . symbol"] : [],
        local.has_invalid_roles ? ["Invalid roles: ${join(", ", local.invalid_roles)}"] : []
      )
    }
  ]

  # Summary statistics
  total_users   = provider::pyvider::length(var.user_registrations)
  valid_users   = [for result in local.validation_results : result if result.is_valid]
  invalid_users = [for result in local.validation_results : result if !result.is_valid]
  valid_count   = provider::pyvider::length(local.valid_users)
  invalid_count = provider::pyvider::length(local.invalid_users)
}

# Configuration validation
variable "service_configs" {
  type = map(object({
    host     = string
    port     = number
    protocol = string
    ssl      = optional(bool, false)
    timeout  = optional(number, 30)
  }))
  default = {
    api = {
      host     = "api.example.com"
      port     = 8080
      protocol = "http"
      ssl      = true
      timeout  = 60
    }
    database = {
      host     = "db.example.com"
      port     = 5432
      protocol = "postgresql"
    }
    cache = {
      host     = "cache.example.com"
      port     = 6379
      protocol = "redis"
      timeout  = 10
    }
  }
}

locals {
  # Define validation rules for services
  valid_protocols         = ["http", "https", "tcp", "postgresql", "mysql", "redis"]
  required_service_fields = ["host", "port", "protocol"]

  # Validate service configurations
  service_validation = {
    for service_name, config in var.service_configs : service_name => {
      # Check required fields
      missing_fields = [
        for field in local.required_service_fields :
        field if !provider::pyvider::contains(config, field)
      ]
      has_all_required = provider::pyvider::length(local.missing_fields) == 0

      # Validate protocol
      protocol_valid = provider::pyvider::contains(local.valid_protocols, config.protocol)

      # Validate SSL consistency
      ssl_protocol_mismatch = (
        provider::pyvider::lookup(config, "ssl", false) == true &&
        config.protocol == "http"
      )

      # Port range validation
      port_in_range = config.port >= 1 && config.port <= 65535

      # Overall validation
      is_valid = (
        local.has_all_required &&
        local.protocol_valid &&
        !local.ssl_protocol_mismatch &&
        local.port_in_range
      )

      # Collect errors
      errors = concat(
        provider::pyvider::length(local.missing_fields) > 0 ? ["Missing fields: ${join(", ", local.missing_fields)}"] : [],
        !local.protocol_valid ? ["Invalid protocol: ${config.protocol}"] : [],
        local.ssl_protocol_mismatch ? ["SSL enabled but protocol is HTTP"] : [],
        !local.port_in_range ? ["Port ${config.port} is out of valid range (1-65535)"] : []
      )
    }
  }

  # Service validation summary
  total_services = provider::pyvider::length(var.service_configs)
  valid_services = [
    for name, validation in local.service_validation :
    name if validation.is_valid
  ]
  invalid_services = [
    for name, validation in local.service_validation :
    name if !validation.is_valid
  ]
  valid_service_count   = provider::pyvider::length(local.valid_services)
  invalid_service_count = provider::pyvider::length(local.invalid_services)
}

# API endpoint validation
variable "api_endpoints" {
  type = list(object({
    path   = string
    method = string
    auth   = optional(bool, true)
    public = optional(bool, false)
  }))
  default = [
    { path = "/users", method = "GET", auth = true },
    { path = "/users", method = "POST", auth = true },
    { path = "/health", method = "GET", auth = false, public = true },
    { path = "/admin/stats", method = "GET", auth = true },
    { path = "/public/info", method = "GET", auth = false, public = true },
    { path = "/invalid-path", method = "PATCH", auth = true } # Invalid method for demo
  ]
}

locals {
  # Define API validation rules
  valid_http_methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]
  admin_paths        = ["/admin", "/management", "/config"]

  # Validate API endpoints
  endpoint_validation = [
    for idx, endpoint in var.api_endpoints : {
      index  = idx
      path   = endpoint.path
      method = endpoint.method

      # Path validation
      path_starts_with_slash = provider::pyvider::contains(endpoint.path, "/") && substr(endpoint.path, 0, 1) == "/"
      path_length_valid      = provider::pyvider::length(endpoint.path) > 1

      # Method validation
      method_valid = provider::pyvider::contains(local.valid_http_methods, endpoint.method)

      # Security validation
      is_admin_path = anytrue([
        for admin_path in local.admin_paths :
        provider::pyvider::contains(endpoint.path, admin_path)
      ])
      admin_path_secure = local.is_admin_path ? endpoint.auth : true

      # Auth/public consistency
      auth_public_conflict = endpoint.auth && provider::pyvider::lookup(endpoint, "public", false)

      # Overall validation
      is_valid = (
        local.path_starts_with_slash &&
        local.path_length_valid &&
        local.method_valid &&
        local.admin_path_secure &&
        !local.auth_public_conflict
      )

      # Collect errors
      errors = concat(
        !local.path_starts_with_slash ? ["Path must start with /"] : [],
        !local.path_length_valid ? ["Path must be longer than 1 character"] : [],
        !local.method_valid ? ["Invalid HTTP method: ${endpoint.method}"] : [],
        !local.admin_path_secure ? ["Admin paths must require authentication"] : [],
        local.auth_public_conflict ? ["Cannot be both authenticated and public"] : []
      )
    }
  ]

  # API endpoint summary
  total_endpoints        = provider::pyvider::length(var.api_endpoints)
  valid_endpoints        = [for result in local.endpoint_validation : result if result.is_valid]
  invalid_endpoints      = [for result in local.endpoint_validation : result if !result.is_valid]
  valid_endpoint_count   = provider::pyvider::length(local.valid_endpoints)
  invalid_endpoint_count = provider::pyvider::length(local.invalid_endpoints)
}

# Create validation reports
resource "pyvider_file_content" "user_validation_report" {
  filename = "/tmp/user_validation_report.txt"
  content = join("\n", concat(
    [
      "=== User Registration Validation Report ===",
      "",
      "Summary:",
      "  Total users: ${local.total_users}",
      "  Valid users: ${local.valid_count}",
      "  Invalid users: ${local.invalid_count}",
      "",
      "Validation Rules:",
      "  - Required fields: ${join(", ", local.required_fields)}",
      "  - Username length: ${local.min_username_length}-${local.max_username_length} characters",
      "  - Username cannot contain @ symbol",
      "  - Email must contain @ and . symbols",
      "  - Valid roles: ${join(", ", local.valid_roles)}",
      "",
      "Results:"
    ],
    flatten([
      for result in local.validation_results : [
        "",
        "User ${result.index + 1}: ${result.username}",
        "  Email: ${result.email}",
        "  Status: ${result.is_valid ? "VALID" : "INVALID"}",
        result.is_valid ? "" : "  Errors: ${join(", ", result.errors)}"
      ]
    ])
  ))
}

resource "pyvider_file_content" "service_validation_report" {
  filename = "/tmp/service_validation_report.txt"
  content = join("\n", concat(
    [
      "=== Service Configuration Validation Report ===",
      "",
      "Summary:",
      "  Total services: ${local.total_services}",
      "  Valid services: ${local.valid_service_count}",
      "  Invalid services: ${local.invalid_service_count}",
      "",
      "Validation Rules:",
      "  - Required fields: ${join(", ", local.required_service_fields)}",
      "  - Valid protocols: ${join(", ", local.valid_protocols)}",
      "  - SSL consistency with protocol",
      "  - Port range: 1-65535",
      "",
      "Results:"
    ],
    flatten([
      for service_name, validation in local.service_validation : [
        "",
        "Service: ${service_name}",
        "  Status: ${validation.is_valid ? "VALID" : "INVALID"}",
        validation.is_valid ? "" : "  Errors: ${join(", ", validation.errors)}"
      ]
    ])
  ))
}

resource "pyvider_file_content" "api_validation_report" {
  filename = "/tmp/api_validation_report.txt"
  content = join("\n", concat(
    [
      "=== API Endpoint Validation Report ===",
      "",
      "Summary:",
      "  Total endpoints: ${local.total_endpoints}",
      "  Valid endpoints: ${local.valid_endpoint_count}",
      "  Invalid endpoints: ${local.invalid_endpoint_count}",
      "",
      "Validation Rules:",
      "  - Path must start with /",
      "  - Valid HTTP methods: ${join(", ", local.valid_http_methods)}",
      "  - Admin paths must require authentication",
      "  - Cannot be both authenticated and public",
      "",
      "Results:"
    ],
    flatten([
      for result in local.endpoint_validation : [
        "",
        "Endpoint ${result.index + 1}: ${result.method} ${result.path}",
        "  Status: ${result.is_valid ? "VALID" : "INVALID"}",
        result.is_valid ? "" : "  Errors: ${join(", ", result.errors)}"
      ]
    ])
  ))
}

# Output validation results
output "data_validation_results" {
  value = {
    user_validation = {
      total       = local.total_users
      valid       = local.valid_count
      invalid     = local.invalid_count
      report_file = pyvider_file_content.user_validation_report.filename
    }

    service_validation = {
      total            = local.total_services
      valid            = local.valid_service_count
      invalid          = local.invalid_service_count
      valid_services   = local.valid_services
      invalid_services = local.invalid_services
      report_file      = pyvider_file_content.service_validation_report.filename
    }

    api_validation = {
      total       = local.total_endpoints
      valid       = local.valid_endpoint_count
      invalid     = local.invalid_endpoint_count
      report_file = pyvider_file_content.api_validation_report.filename
    }

    summary = {
      all_users_valid     = local.invalid_count == 0
      all_services_valid  = local.invalid_service_count == 0
      all_endpoints_valid = local.invalid_endpoint_count == 0
      overall_valid = (
        local.invalid_count == 0 &&
        local.invalid_service_count == 0 &&
        local.invalid_endpoint_count == 0
      )
    }
  }
}


