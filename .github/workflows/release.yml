name: üè∑Ô∏è GitHub Release

on:
  workflow_dispatch:
    inputs:
      prerelease:
        description: 'Is this a pre-release?'
        required: false
        type: boolean
        default: false
      generate_docs:
        description: 'Generate and commit documentation'
        required: false
        type: boolean
        default: true
      build_run_id:
        description: 'Build workflow run ID (leave empty to trigger new build)'
        required: false
        type: string

env:
  PYTHON_VERSION: '3.11'

jobs:
  # Optionally trigger a new build if no build_run_id provided
  trigger_build:
    name: üèóÔ∏è Trigger Build
    runs-on: ubuntu-24.04
    if: inputs.build_run_id == ''
    outputs:
      run_id: ${{ steps.trigger.outputs.run_id }}

    steps:
      - name: üî® Trigger build workflow
        id: trigger
        uses: actions/github-script@v7
        with:
          script: |
            const response = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-provider.yml',
              ref: context.ref
            });

            // Wait a bit for the workflow to start
            await new Promise(resolve => setTimeout(resolve, 5000));

            // Get the latest run
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-provider.yml',
              per_page: 1
            });

            const runId = runs.data.workflow_runs[0].id;
            core.setOutput('run_id', runId);
            console.log(`Build workflow triggered: ${runId}`);

  # Wait for build to complete
  wait_for_build:
    name: ‚è≥ Wait for Build
    needs: trigger_build
    if: always() && (inputs.build_run_id != '' || needs.trigger_build.outputs.run_id != '')
    runs-on: ubuntu-24.04
    outputs:
      build_run_id: ${{ steps.wait.outputs.build_run_id }}

    steps:
      - name: ‚è≥ Wait for build completion
        id: wait
        uses: actions/github-script@v7
        with:
          script: |
            const runId = '${{ inputs.build_run_id }}' || '${{ needs.trigger_build.outputs.run_id }}';
            core.setOutput('build_run_id', runId);

            if ('${{ inputs.build_run_id }}' !== '') {
              console.log('Using provided build_run_id:', runId);
              return;
            }

            console.log('Waiting for build workflow to complete:', runId);

            let status = 'in_progress';
            let attempts = 0;
            const maxAttempts = 60; // 30 minutes max wait

            while (status === 'in_progress' && attempts < maxAttempts) {
              const run = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId
              });

              status = run.data.status;
              const conclusion = run.data.conclusion;

              console.log(`Build status: ${status}, conclusion: ${conclusion}`);

              if (status === 'completed') {
                if (conclusion !== 'success') {
                  core.setFailed(`Build workflow failed with conclusion: ${conclusion}`);
                  return;
                }
                break;
              }

              await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30s
              attempts++;
            }

            if (attempts >= maxAttempts) {
              core.setFailed('Timeout waiting for build workflow');
            }

  release:
    name: üéâ Create Release
    needs: wait_for_build
    if: always() && needs.wait_for_build.result == 'success'
    runs-on: ubuntu-24.04
    permissions:
      contents: write

    steps:
      - name: ü§ñ Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.PROVIDE_BOT_APP_ID }}
          private-key: ${{ secrets.PROVIDE_BOT_PRIVATE_KEY }}

      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'
          token: ${{ steps.app-token.outputs.token }}

      - name: üìñ Read VERSION
        id: version
        run: |
          VERSION=$(cat VERSION)
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "üì¶ Releasing version: ${VERSION}"

      - name: üêç Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: üì¶ Install UV
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: false

      - name: üß∞ Install wrknv
        run: |
          uv tool install git+https://github.com/provide-io/wrknv.git
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: üìö Generate Documentation
        if: inputs.generate_docs == true
        run: |
          echo "üìù Generating documentation and examples with plating..."

          # Install project dependencies and dev tools (includes plating and pyvider-components)
          uv sync --all-groups

          # Generate documentation via wrknv task
          we run docs.build

          echo "‚úÖ Documentation and examples generated"
          ls -la docs/

      - name: üíæ Commit Documentation
        if: inputs.generate_docs == true
        run: |
          # Configure git with providebot[bot] identity
          git config user.name "providebot[bot]"
          git config user.email "178697328+providebot[bot]@users.noreply.github.com"

          # Add generated documentation
          git add docs/

          # Commit if there are changes
          if git diff --staged --quiet; then
            echo "üìù No documentation changes to commit"
          else
            git commit -m "Generate documentation for v${{ steps.version.outputs.VERSION }}"
            git push origin main
            echo "‚úÖ Documentation committed and pushed"
          fi

      - name: üì• Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          run-id: ${{ needs.wait_for_build.outputs.build_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: üìÅ Organize release files
        run: |
          mkdir -p release

          # Move all zip files to release directory
          find artifacts -name "*.zip" -type f -exec mv {} release/ \;

          # Copy and rename manifest file
          cp terraform-registry-manifest.json "release/terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_manifest.json"

          echo "üì¶ Release files:"
          ls -la release/

      - name: üîß Generate checksums
        run: |
          cd release

          # Generate SHA256 checksums for all files
          sha256sum * > "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS"

          echo "üìù Checksums:"
          cat "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS"

      - name: üîê Sign checksums with GPG
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
        run: |
          chmod +x .github/scripts/sign-release.sh
          .github/scripts/sign-release.sh release/

          echo "‚úÖ Signatures created:"
          ls -la release/*.sig

      - name: üîç Verify release artifacts
        run: |
          cd release
          echo "üìã Verifying release artifacts for Terraform Registry..."

          # Check all required files exist
          REQUIRED_FILES=(
            "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_linux_amd64.zip"
            "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_linux_arm64.zip"
            "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_darwin_amd64.zip"
            "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_darwin_arm64.zip"
            "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_manifest.json"
            "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS"
            "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS.sig"
          )

          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              echo "‚ùå Missing required file: $file"
              exit 1
            else
              echo "‚úÖ Found: $file"
            fi
          done

          # Verify SHA256SUMS contains all required entries
          echo -e "\nüìù Checking SHA256SUMS entries..."
          for platform in linux_amd64 linux_arm64 darwin_amd64 darwin_arm64; do
            if grep -q "${platform}.zip" "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS"; then
              echo "‚úÖ SHA256SUMS contains ${platform}"
            else
              echo "‚ùå SHA256SUMS missing ${platform}"
              exit 1
            fi
          done

          # Verify manifest.json
          if grep -q "manifest.json" "terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS"; then
            echo "‚úÖ SHA256SUMS contains manifest.json"
          else
            echo "‚ùå SHA256SUMS missing manifest.json"
            exit 1
          fi

          echo -e "\n‚úÖ All release artifacts verified!"

      - name: üìù Generate release notes
        run: |
          cat > release-notes.md << EOF
          # Terraform Provider Pyvider v${{ steps.version.outputs.VERSION }}

          ## üì¶ Installation

          ### Terraform Registry (Coming Soon)
          \`\`\`hcl
          terraform {
            required_providers {
              pyvider = {
                source  = "provide-io/pyvider"
                version = "${{ steps.version.outputs.VERSION }}"
              }
            }
          }
          \`\`\`

          ### Manual Installation
          1. Download the appropriate package for your platform from the assets below
          2. Extract the archive to get the provider binary
          3. Place it in your Terraform plugins directory

          ## üîí Verification

          Verify your download with:
          \`\`\`bash
          # Download the SHA256SUMS and signature files
          curl -LO https://github.com/provide-io/terraform-provider-pyvider/releases/download/v${{ steps.version.outputs.VERSION }}/terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS
          curl -LO https://github.com/provide-io/terraform-provider-pyvider/releases/download/v${{ steps.version.outputs.VERSION }}/terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS.sig

          # Verify the signature
          gpg --verify terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS.sig terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS

          # Verify the checksum
          sha256sum -c terraform-provider-pyvider_${{ steps.version.outputs.VERSION }}_SHA256SUMS 2>&1 | grep OK
          \`\`\`

          ## üìã Supported Platforms

          - Linux AMD64
          - Linux ARM64
          - macOS ARM64 (Apple Silicon)
          - macOS AMD64 (Intel)

          ## üöÄ What's New

          Built with Pyvider framework - Python-based Terraform provider development.
          EOF

      - name: üè∑Ô∏è Create Git tag
        run: |
          # Configure git with providebot[bot] identity
          git config user.name "providebot[bot]"
          git config user.email "178697328+providebot[bot]@users.noreply.github.com"

          # Create and push tag (ensure it exists before release)
          git tag -a "v${{ steps.version.outputs.VERSION }}" -m "Release v${{ steps.version.outputs.VERSION }}" || echo "Tag might already exist"
          git push origin "v${{ steps.version.outputs.VERSION }}" || echo "Tag already exists on remote"

      - name: üöÄ Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          tag: "v${{ steps.version.outputs.VERSION }}"
          name: "v${{ steps.version.outputs.VERSION }}"
          bodyFile: "release-notes.md"
          artifacts: "release/*"
          prerelease: ${{ inputs.prerelease }}
          token: ${{ secrets.GITHUB_TOKEN }}
